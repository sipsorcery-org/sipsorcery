// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace vpxmd
{
    /// <summary>Multi-pass Encoding Pass</summary>
    public enum VpxEncPass
    {
        /// <summary>Single pass mode</summary>
        VPX_RC_ONE_PASS = 0,
        /// <summary>First pass of multi-pass mode</summary>
        VPX_RC_FIRST_PASS = 1,
        /// <summary>Final pass of multi-pass mode</summary>
        VPX_RC_LAST_PASS = 2
    }

    /// <summary>Rate control mode</summary>
    public enum VpxRcMode
    {
        /// <summary>Variable Bit Rate (VBR) mode</summary>
        VPX_VBR = 0,
        /// <summary>Constant Bit Rate (CBR) mode</summary>
        VPX_CBR = 1,
        /// <summary>Constrained Quality (CQ)  mode</summary>
        VPX_CQ = 2,
        /// <summary>Constant Quality (Q) mode</summary>
        VPX_Q = 3
    }

    /// <summary>Keyframe placement mode.</summary>
    /// <remarks>
    /// <para>This enumeration determines whether keyframes are placed automatically by</para>
    /// <para>the encoder or whether this behavior is disabled. Older releases of this</para>
    /// <para>SDK were implemented such that VPX_KF_FIXED meant keyframes were disabled.</para>
    /// <para>This name is confusing for this behavior, so the new symbols to be used</para>
    /// <para>are VPX_KF_AUTO and VPX_KF_DISABLED.</para>
    /// </remarks>
    public enum VpxKfMode
    {
        /// <summary>deprecated, implies VPX_KF_DISABLED</summary>
        VPX_KF_FIXED = 0,
        /// <summary>Encoder determines optimal placement automatically</summary>
        VPX_KF_AUTO = 1,
        /// <summary>Encoder does not place keyframes.</summary>
        VPX_KF_DISABLED = 0
    }

    /// <summary>Encoder output packet variants</summary>
    /// <remarks>
    /// <para>This enumeration lists the different kinds of data packets that can be</para>
    /// <para>returned by calls to vpx_codec_get_cx_data(). Algorithms</para>
    /// <para>extend this list to provide additional functionality.</para>
    /// </remarks>
    public enum VpxCodecCxPktKind
    {
        /// <summary>Compressed video frame</summary>
        VPX_CODEC_CX_FRAME_PKT = 0,
        /// <summary>Two-pass statistics for this frame</summary>
        VPX_CODEC_STATS_PKT = 1,
        /// <summary>first pass mb statistics for this frame</summary>
        VPX_CODEC_FPMB_STATS_PKT = 2,
        /// <summary>PSNR statistics for this frame</summary>
        VPX_CODEC_PSNR_PKT = 3,
        /// <summary>Algorithm extensions</summary>
        VPX_CODEC_CUSTOM_PKT = 256
    }

    /// <summary>Error Resilient flags</summary>
    /// <remarks>
    /// <para>These flags define which error resilient features to enable in the</para>
    /// <para>encoder. The flags are specified through the</para>
    /// <para>vpx_codec_enc_cfg::g_error_resilient variable.</para>
    /// </remarks>
    /// <summary>Generic fixed size buffer structure</summary>
    /// <remarks>This structure is able to hold a reference to any fixed size buffer.</remarks>
    /// <summary>Time Stamp Type</summary>
    /// <remarks>
    /// <para>An integer, which when multiplied by the stream's time base, provides</para>
    /// <para>the absolute time of a sample.</para>
    /// </remarks>
    /// <summary>Compressed Frame Flags</summary>
    /// <remarks>
    /// <para>This type represents a bitfield containing information about a compressed</para>
    /// <para>frame that may be useful to an application. The most significant 16 bits</para>
    /// <para>can be used by an algorithm to provide additional detail, for example to</para>
    /// <para>support frame types that are codec specific (MPEG-1 D-frames for example)</para>
    /// </remarks>
    /// <summary>Encoder output packet</summary>
    /// <remarks>
    /// <para>This structure contains the different kinds of output data the encoder</para>
    /// <para>may produce while compressing a frame.</para>
    /// </remarks>
    /// <summary>Encoder return output buffer callback</summary>
    /// <remarks>
    /// <para>This callback function, when registered, returns with packets when each</para>
    /// <para>spatial layer is encoded.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void VpxCodecEncOutputCxPktCbFnT(global::System.IntPtr pkt, global::System.IntPtr user_data);

    /// <summary>Callback function pointer / user data pair storage</summary>
    /// <summary>Rational Number</summary>
    /// <remarks>This structure holds a fractional value.</remarks>
    /// <summary>Multi-pass Encoding Pass</summary>
    /// <summary>Encoded Frame Flags</summary>
    /// <remarks>
    /// <para>This type indicates a bitfield to be passed to vpx_codec_encode(), defining</para>
    /// <para>per-frame boolean values. By convention, bits common to all codecs will be</para>
    /// <para>named VPX_EFLAG_*, and bits specific to an algorithm will be named</para>
    /// <para>/algo/_eflag_*. The lower order 16 bits are reserved for common use.</para>
    /// </remarks>
    /// <summary>Encoder configuration structure</summary>
    /// <remarks>
    /// <para>This structure contains the encoder settings that have common representations</para>
    /// <para>across all codecs. This doesn't imply that all codecs support all features,</para>
    /// <para>however.</para>
    /// </remarks>
    /// <summary>vp9 svc extra configure parameters</summary>
    /// <remarks>This defines max/min quantizers and scale factors for each layer</remarks>
    /// <summary>Generic fixed size buffer structure</summary>
    /// <remarks>This structure is able to hold a reference to any fixed size buffer.</remarks>
    public unsafe partial class VpxFixedBuf : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr buf;

            [FieldOffset(8)]
            internal ulong sz;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_fixed_buf@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxFixedBuf> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxFixedBuf>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxFixedBuf __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxFixedBuf(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxFixedBuf __CreateInstance(global::vpxmd.VpxFixedBuf.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxFixedBuf(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxFixedBuf.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxFixedBuf.__Internal));
            *(global::vpxmd.VpxFixedBuf.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxFixedBuf(global::vpxmd.VpxFixedBuf.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxFixedBuf(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxFixedBuf()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxFixedBuf.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxFixedBuf(global::vpxmd.VpxFixedBuf _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxFixedBuf.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxFixedBuf.__Internal*) __Instance) = *((global::vpxmd.VpxFixedBuf.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxFixedBuf __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr Buf
        {
            get
            {
                return ((global::vpxmd.VpxFixedBuf.__Internal*) __Instance)->buf;
            }

            set
            {
                ((global::vpxmd.VpxFixedBuf.__Internal*)__Instance)->buf = (global::System.IntPtr) value;
            }
        }

        public ulong Sz
        {
            get
            {
                return ((global::vpxmd.VpxFixedBuf.__Internal*) __Instance)->sz;
            }

            set
            {
                ((global::vpxmd.VpxFixedBuf.__Internal*)__Instance)->sz = value;
            }
        }
    }

    /// <summary>Encoder output packet</summary>
    /// <remarks>
    /// <para>This structure contains the different kinds of output data the encoder</para>
    /// <para>may produce while compressing a frame.</para>
    /// </remarks>
    public unsafe partial class VpxCodecCxPkt : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::vpxmd.VpxCodecCxPktKind kind;

            [FieldOffset(8)]
            internal global::vpxmd.VpxCodecCxPkt.Data.__Internal data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_codec_cx_pkt@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public unsafe partial struct Data
        {
            [StructLayout(LayoutKind.Explicit, Size = 128)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal frame;

                [FieldOffset(0)]
                internal global::vpxmd.VpxFixedBuf.__Internal twopass_stats;

                [FieldOffset(0)]
                internal global::vpxmd.VpxFixedBuf.__Internal firstpass_mb_stats;

                [FieldOffset(0)]
                internal global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal psnr;

                [FieldOffset(0)]
                internal global::vpxmd.VpxFixedBuf.__Internal raw;

                [FieldOffset(0)]
                internal fixed sbyte pad[124];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0<unnamed-type-data>@vpx_codec_cx_pkt@@QEAA@AEBT01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
            }

            public unsafe partial class Frame : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr buf;

                    [FieldOffset(8)]
                    internal ulong sz;

                    [FieldOffset(16)]
                    internal long pts;

                    [FieldOffset(24)]
                    internal uint duration;

                    [FieldOffset(28)]
                    internal uint flags;

                    [FieldOffset(32)]
                    internal int partition_id;

                    [FieldOffset(36)]
                    internal fixed uint width[5];

                    [FieldOffset(56)]
                    internal fixed uint height[5];

                    [FieldOffset(76)]
                    internal fixed byte spatial_layer_encoded[5];

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0<unnamed-type-frame>@<unnamed-type-data>@vpx_codec_cx_pkt@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCxPkt.Data.Frame> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCxPkt.Data.Frame>();

                protected bool __ownsNativeInstance;

                internal static global::vpxmd.VpxCodecCxPkt.Data.Frame __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::vpxmd.VpxCodecCxPkt.Data.Frame(native.ToPointer(), skipVTables);
                }

                internal static global::vpxmd.VpxCodecCxPkt.Data.Frame __CreateInstance(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal native, bool skipVTables = false)
                {
                    return new global::vpxmd.VpxCodecCxPkt.Data.Frame(native, skipVTables);
                }

                private static void* __CopyValue(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal));
                    *(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Frame(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Frame(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Frame()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Frame(global::vpxmd.VpxCodecCxPkt.Data.Frame _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance) = *((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::vpxmd.VpxCodecCxPkt.Data.Frame __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::System.IntPtr Buf
                {
                    get
                    {
                        return ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->buf;
                    }

                    set
                    {
                        ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->buf = (global::System.IntPtr) value;
                    }
                }

                public ulong Sz
                {
                    get
                    {
                        return ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->sz;
                    }

                    set
                    {
                        ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->sz = value;
                    }
                }

                public long Pts
                {
                    get
                    {
                        return ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->pts;
                    }

                    set
                    {
                        ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->pts = value;
                    }
                }

                public uint Duration
                {
                    get
                    {
                        return ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->duration;
                    }

                    set
                    {
                        ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->duration = value;
                    }
                }

                public uint Flags
                {
                    get
                    {
                        return ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->flags;
                    }

                    set
                    {
                        ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->flags = value;
                    }
                }

                public int PartitionId
                {
                    get
                    {
                        return ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->partition_id;
                    }

                    set
                    {
                        ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->partition_id = value;
                    }
                }

                public uint[] Width
                {
                    get
                    {
                        uint[] __value = null;
                        if (((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->width != null)
                        {
                            __value = new uint[5];
                            for (int i = 0; i < 5; i++)
                                __value[i] = ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->width[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 5; i++)
                                ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->width[i] = value[i];
                        }
                    }
                }

                public uint[] Height
                {
                    get
                    {
                        uint[] __value = null;
                        if (((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->height != null)
                        {
                            __value = new uint[5];
                            for (int i = 0; i < 5; i++)
                                __value[i] = ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->height[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 5; i++)
                                ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->height[i] = value[i];
                        }
                    }
                }

                public byte[] SpatialLayerEncoded
                {
                    get
                    {
                        byte[] __value = null;
                        if (((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->spatial_layer_encoded != null)
                        {
                            __value = new byte[5];
                            for (int i = 0; i < 5; i++)
                                __value[i] = ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance)->spatial_layer_encoded[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 5; i++)
                                ((global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*)__Instance)->spatial_layer_encoded[i] = value[i];
                        }
                    }
                }
            }

            public unsafe partial class VpxPsnrPkt : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed uint samples[4];

                    [FieldOffset(16)]
                    internal fixed ulong sse[4];

                    [FieldOffset(48)]
                    internal fixed double psnr[4];

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0vpx_psnr_pkt@<unnamed-type-data>@vpx_codec_cx_pkt@@QEAA@AEBU012@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt>();

                protected bool __ownsNativeInstance;

                internal static global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt(native.ToPointer(), skipVTables);
                }

                internal static global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt __CreateInstance(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal native, bool skipVTables = false)
                {
                    return new global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt(native, skipVTables);
                }

                private static void* __CopyValue(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal));
                    *(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private VpxPsnrPkt(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VpxPsnrPkt(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VpxPsnrPkt()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public VpxPsnrPkt(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance) = *((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint[] Samples
                {
                    get
                    {
                        uint[] __value = null;
                        if (((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance)->samples != null)
                        {
                            __value = new uint[4];
                            for (int i = 0; i < 4; i++)
                                __value[i] = ((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance)->samples[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 4; i++)
                                ((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*)__Instance)->samples[i] = value[i];
                        }
                    }
                }

                public ulong[] Sse
                {
                    get
                    {
                        ulong[] __value = null;
                        if (((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance)->sse != null)
                        {
                            __value = new ulong[4];
                            for (int i = 0; i < 4; i++)
                                __value[i] = ((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance)->sse[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 4; i++)
                                ((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*)__Instance)->sse[i] = value[i];
                        }
                    }
                }

                public double[] Psnr
                {
                    get
                    {
                        double[] __value = null;
                        if (((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance)->psnr != null)
                        {
                            __value = new double[4];
                            for (int i = 0; i < 4; i++)
                                __value[i] = ((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance)->psnr[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 4; i++)
                                ((global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*)__Instance)->psnr[i] = value[i];
                        }
                    }
                }
            }

            private Data.__Internal __instance;
            internal Data.__Internal __Instance { get { return __instance; } }

            internal static global::vpxmd.VpxCodecCxPkt.Data __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::vpxmd.VpxCodecCxPkt.Data(native.ToPointer(), skipVTables);
            }

            internal static global::vpxmd.VpxCodecCxPkt.Data __CreateInstance(global::vpxmd.VpxCodecCxPkt.Data.__Internal native, bool skipVTables = false)
            {
                return new global::vpxmd.VpxCodecCxPkt.Data(native, skipVTables);
            }

            private Data(global::vpxmd.VpxCodecCxPkt.Data.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Data(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::vpxmd.VpxCodecCxPkt.Data.__Internal*) native;
            }

            public Data(global::vpxmd.VpxCodecCxPkt.Data _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            public global::vpxmd.VpxCodecCxPkt.Data.Frame frame
            {
                get
                {
                    return global::vpxmd.VpxCodecCxPkt.Data.Frame.__CreateInstance(__instance.frame);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.frame = *(global::vpxmd.VpxCodecCxPkt.Data.Frame.__Internal*) value.__Instance;
                }
            }

            public global::vpxmd.VpxFixedBuf TwopassStats
            {
                get
                {
                    return global::vpxmd.VpxFixedBuf.__CreateInstance(__instance.twopass_stats);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.twopass_stats = *(global::vpxmd.VpxFixedBuf.__Internal*) value.__Instance;
                }
            }

            public global::vpxmd.VpxFixedBuf FirstpassMbStats
            {
                get
                {
                    return global::vpxmd.VpxFixedBuf.__CreateInstance(__instance.firstpass_mb_stats);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.firstpass_mb_stats = *(global::vpxmd.VpxFixedBuf.__Internal*) value.__Instance;
                }
            }

            public global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt Psnr
            {
                get
                {
                    return global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__CreateInstance(__instance.psnr);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.psnr = *(global::vpxmd.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) value.__Instance;
                }
            }

            public global::vpxmd.VpxFixedBuf Raw
            {
                get
                {
                    return global::vpxmd.VpxFixedBuf.__CreateInstance(__instance.raw);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.raw = *(global::vpxmd.VpxFixedBuf.__Internal*) value.__Instance;
                }
            }

            public sbyte[] Pad
            {
                get
                {
                    fixed (sbyte* __arrPtr = __instance.pad)
                    {
                        sbyte[] __value = null;
                        if (__arrPtr != null)
                        {
                            __value = new sbyte[124];
                            for (int i = 0; i < 124; i++)
                                __value[i] = __arrPtr[i];
                        }
                        return __value;
                    }
                }

                set
                {
                    fixed (sbyte* __arrPtr = __instance.pad)
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 124; i++)
                                __arrPtr[i] = value[i];
                        }
                    }
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCxPkt> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCxPkt>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecCxPkt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecCxPkt(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecCxPkt __CreateInstance(global::vpxmd.VpxCodecCxPkt.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecCxPkt(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecCxPkt.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.__Internal));
            *(global::vpxmd.VpxCodecCxPkt.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecCxPkt(global::vpxmd.VpxCodecCxPkt.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecCxPkt(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxCodecCxPkt()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxCodecCxPkt(global::vpxmd.VpxCodecCxPkt _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCxPkt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxCodecCxPkt.__Internal*) __Instance) = *((global::vpxmd.VpxCodecCxPkt.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxCodecCxPkt __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::vpxmd.VpxCodecCxPktKind Kind
        {
            get
            {
                return ((global::vpxmd.VpxCodecCxPkt.__Internal*) __Instance)->kind;
            }

            set
            {
                ((global::vpxmd.VpxCodecCxPkt.__Internal*)__Instance)->kind = value;
            }
        }

        public global::vpxmd.VpxCodecCxPkt.Data data
        {
            get
            {
                return global::vpxmd.VpxCodecCxPkt.Data.__CreateInstance(((global::vpxmd.VpxCodecCxPkt.__Internal*) __Instance)->data);
            }

            set
            {
                ((global::vpxmd.VpxCodecCxPkt.__Internal*)__Instance)->data = value.__Instance;
            }
        }
    }

    /// <summary>Callback function pointer / user data pair storage</summary>
    public unsafe partial class VpxCodecEncOutputCxCbPair : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr output_cx_pkt;

            [FieldOffset(8)]
            internal global::System.IntPtr user_priv;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_codec_enc_output_cx_cb_pair@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecEncOutputCxCbPair> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecEncOutputCxCbPair>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecEncOutputCxCbPair __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecEncOutputCxCbPair(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecEncOutputCxCbPair __CreateInstance(global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecEncOutputCxCbPair(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal));
            *(global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecEncOutputCxCbPair(global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecEncOutputCxCbPair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxCodecEncOutputCxCbPair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxCodecEncOutputCxCbPair(global::vpxmd.VpxCodecEncOutputCxCbPair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal*) __Instance) = *((global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxCodecEncOutputCxCbPair __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::vpxmd.VpxCodecEncOutputCxPktCbFnT OutputCxPkt
        {
            get
            {
                var __ptr0 = ((global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal*) __Instance)->output_cx_pkt;
                return __ptr0 == IntPtr.Zero? null : (global::vpxmd.VpxCodecEncOutputCxPktCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::vpxmd.VpxCodecEncOutputCxPktCbFnT));
            }

            set
            {
                ((global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal*)__Instance)->output_cx_pkt = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr UserPriv
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal*) __Instance)->user_priv;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncOutputCxCbPair.__Internal*)__Instance)->user_priv = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>Rational Number</summary>
    /// <remarks>This structure holds a fractional value.</remarks>
    public unsafe partial class VpxRational : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int num;

            [FieldOffset(4)]
            internal int den;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_rational@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxRational> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxRational>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxRational __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxRational(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxRational __CreateInstance(global::vpxmd.VpxRational.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxRational(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxRational.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRational.__Internal));
            *(global::vpxmd.VpxRational.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRational(global::vpxmd.VpxRational.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxRational(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxRational()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRational.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxRational(global::vpxmd.VpxRational _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRational.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxRational.__Internal*) __Instance) = *((global::vpxmd.VpxRational.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxRational __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Num
        {
            get
            {
                return ((global::vpxmd.VpxRational.__Internal*) __Instance)->num;
            }

            set
            {
                ((global::vpxmd.VpxRational.__Internal*)__Instance)->num = value;
            }
        }

        public int Den
        {
            get
            {
                return ((global::vpxmd.VpxRational.__Internal*) __Instance)->den;
            }

            set
            {
                ((global::vpxmd.VpxRational.__Internal*)__Instance)->den = value;
            }
        }
    }

    /// <summary>Encoder configuration structure</summary>
    /// <remarks>
    /// <para>This structure contains the encoder settings that have common representations</para>
    /// <para>across all codecs. This doesn't imply that all codecs support all features,</para>
    /// <para>however.</para>
    /// </remarks>
    public unsafe partial class VpxCodecEncCfg : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 384)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint g_usage;

            [FieldOffset(4)]
            internal uint g_threads;

            [FieldOffset(8)]
            internal uint g_profile;

            [FieldOffset(12)]
            internal uint g_w;

            [FieldOffset(16)]
            internal uint g_h;

            [FieldOffset(20)]
            internal global::vpxmd.VpxBitDepth g_bit_depth;

            [FieldOffset(24)]
            internal uint g_input_bit_depth;

            [FieldOffset(28)]
            internal global::vpxmd.VpxRational.__Internal g_timebase;

            [FieldOffset(36)]
            internal uint g_error_resilient;

            [FieldOffset(40)]
            internal global::vpxmd.VpxEncPass g_pass;

            [FieldOffset(44)]
            internal uint g_lag_in_frames;

            [FieldOffset(48)]
            internal uint rc_dropframe_thresh;

            [FieldOffset(52)]
            internal uint rc_resize_allowed;

            [FieldOffset(56)]
            internal uint rc_scaled_width;

            [FieldOffset(60)]
            internal uint rc_scaled_height;

            [FieldOffset(64)]
            internal uint rc_resize_up_thresh;

            [FieldOffset(68)]
            internal uint rc_resize_down_thresh;

            [FieldOffset(72)]
            internal global::vpxmd.VpxRcMode rc_end_usage;

            [FieldOffset(80)]
            internal global::vpxmd.VpxFixedBuf.__Internal rc_twopass_stats_in;

            [FieldOffset(96)]
            internal global::vpxmd.VpxFixedBuf.__Internal rc_firstpass_mb_stats_in;

            [FieldOffset(112)]
            internal uint rc_target_bitrate;

            [FieldOffset(116)]
            internal uint rc_min_quantizer;

            [FieldOffset(120)]
            internal uint rc_max_quantizer;

            [FieldOffset(124)]
            internal uint rc_undershoot_pct;

            [FieldOffset(128)]
            internal uint rc_overshoot_pct;

            [FieldOffset(132)]
            internal uint rc_buf_sz;

            [FieldOffset(136)]
            internal uint rc_buf_initial_sz;

            [FieldOffset(140)]
            internal uint rc_buf_optimal_sz;

            [FieldOffset(144)]
            internal uint rc_2pass_vbr_bias_pct;

            [FieldOffset(148)]
            internal uint rc_2pass_vbr_minsection_pct;

            [FieldOffset(152)]
            internal uint rc_2pass_vbr_maxsection_pct;

            [FieldOffset(156)]
            internal uint rc_2pass_vbr_corpus_complexity;

            [FieldOffset(160)]
            internal global::vpxmd.VpxKfMode kf_mode;

            [FieldOffset(164)]
            internal uint kf_min_dist;

            [FieldOffset(168)]
            internal uint kf_max_dist;

            [FieldOffset(172)]
            internal uint ss_number_layers;

            [FieldOffset(176)]
            internal fixed int ss_enable_auto_alt_ref[5];

            [FieldOffset(196)]
            internal fixed uint ss_target_bitrate[5];

            [FieldOffset(216)]
            internal uint ts_number_layers;

            [FieldOffset(220)]
            internal fixed uint ts_target_bitrate[5];

            [FieldOffset(240)]
            internal fixed uint ts_rate_decimator[5];

            [FieldOffset(260)]
            internal uint ts_periodicity;

            [FieldOffset(264)]
            internal fixed uint ts_layer_id[16];

            [FieldOffset(328)]
            internal fixed uint layer_target_bitrate[12];

            [FieldOffset(376)]
            internal int temporal_layering_mode;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_codec_enc_cfg@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecEncCfg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecEncCfg>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecEncCfg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecEncCfg(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecEncCfg __CreateInstance(global::vpxmd.VpxCodecEncCfg.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecEncCfg(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecEncCfg.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecEncCfg.__Internal));
            *(global::vpxmd.VpxCodecEncCfg.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecEncCfg(global::vpxmd.VpxCodecEncCfg.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecEncCfg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxCodecEncCfg()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecEncCfg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxCodecEncCfg(global::vpxmd.VpxCodecEncCfg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecEncCfg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance) = *((global::vpxmd.VpxCodecEncCfg.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxCodecEncCfg __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint GUsage
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_usage;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_usage = value;
            }
        }

        public uint GThreads
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_threads;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_threads = value;
            }
        }

        public uint GProfile
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_profile;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_profile = value;
            }
        }

        public uint GW
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_w;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_w = value;
            }
        }

        public uint GH
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_h;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_h = value;
            }
        }

        public global::vpxmd.VpxBitDepth GBitDepth
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_bit_depth;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_bit_depth = value;
            }
        }

        public uint GInputBitDepth
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_input_bit_depth;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_input_bit_depth = value;
            }
        }

        public global::vpxmd.VpxRational GTimebase
        {
            get
            {
                return global::vpxmd.VpxRational.__CreateInstance(new global::System.IntPtr(&((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_timebase));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_timebase = *(global::vpxmd.VpxRational.__Internal*) value.__Instance;
            }
        }

        public uint GErrorResilient
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_error_resilient;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_error_resilient = value;
            }
        }

        public global::vpxmd.VpxEncPass GPass
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_pass;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_pass = value;
            }
        }

        public uint GLagInFrames
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->g_lag_in_frames;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->g_lag_in_frames = value;
            }
        }

        public uint RcDropframeThresh
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_dropframe_thresh;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_dropframe_thresh = value;
            }
        }

        public uint RcResizeAllowed
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_resize_allowed;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_resize_allowed = value;
            }
        }

        public uint RcScaledWidth
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_scaled_width;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_scaled_width = value;
            }
        }

        public uint RcScaledHeight
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_scaled_height;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_scaled_height = value;
            }
        }

        public uint RcResizeUpThresh
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_resize_up_thresh;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_resize_up_thresh = value;
            }
        }

        public uint RcResizeDownThresh
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_resize_down_thresh;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_resize_down_thresh = value;
            }
        }

        public global::vpxmd.VpxRcMode RcEndUsage
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_end_usage;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_end_usage = value;
            }
        }

        public global::vpxmd.VpxFixedBuf RcTwopassStatsIn
        {
            get
            {
                return global::vpxmd.VpxFixedBuf.__CreateInstance(new global::System.IntPtr(&((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_twopass_stats_in));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_twopass_stats_in = *(global::vpxmd.VpxFixedBuf.__Internal*) value.__Instance;
            }
        }

        public global::vpxmd.VpxFixedBuf RcFirstpassMbStatsIn
        {
            get
            {
                return global::vpxmd.VpxFixedBuf.__CreateInstance(new global::System.IntPtr(&((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_firstpass_mb_stats_in));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_firstpass_mb_stats_in = *(global::vpxmd.VpxFixedBuf.__Internal*) value.__Instance;
            }
        }

        public uint RcTargetBitrate
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_target_bitrate;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_target_bitrate = value;
            }
        }

        public uint RcMinQuantizer
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_min_quantizer;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_min_quantizer = value;
            }
        }

        public uint RcMaxQuantizer
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_max_quantizer;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_max_quantizer = value;
            }
        }

        public uint RcUndershootPct
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_undershoot_pct;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_undershoot_pct = value;
            }
        }

        public uint RcOvershootPct
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_overshoot_pct;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_overshoot_pct = value;
            }
        }

        public uint RcBufSz
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_buf_sz;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_buf_sz = value;
            }
        }

        public uint RcBufInitialSz
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_buf_initial_sz;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_buf_initial_sz = value;
            }
        }

        public uint RcBufOptimalSz
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_buf_optimal_sz;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_buf_optimal_sz = value;
            }
        }

        public uint Rc2passVbrBiasPct
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_2pass_vbr_bias_pct;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_2pass_vbr_bias_pct = value;
            }
        }

        public uint Rc2passVbrMinsectionPct
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_2pass_vbr_minsection_pct;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_2pass_vbr_minsection_pct = value;
            }
        }

        public uint Rc2passVbrMaxsectionPct
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_2pass_vbr_maxsection_pct;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_2pass_vbr_maxsection_pct = value;
            }
        }

        public uint Rc2passVbrCorpusComplexity
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->rc_2pass_vbr_corpus_complexity;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->rc_2pass_vbr_corpus_complexity = value;
            }
        }

        public global::vpxmd.VpxKfMode KfMode
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->kf_mode;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->kf_mode = value;
            }
        }

        public uint KfMinDist
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->kf_min_dist;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->kf_min_dist = value;
            }
        }

        public uint KfMaxDist
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->kf_max_dist;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->kf_max_dist = value;
            }
        }

        public uint SsNumberLayers
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ss_number_layers;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ss_number_layers = value;
            }
        }

        public int[] SsEnableAutoAltRef
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ss_enable_auto_alt_ref != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ss_enable_auto_alt_ref[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ss_enable_auto_alt_ref[i] = value[i];
                }
            }
        }

        public uint[] SsTargetBitrate
        {
            get
            {
                uint[] __value = null;
                if (((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ss_target_bitrate != null)
                {
                    __value = new uint[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ss_target_bitrate[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ss_target_bitrate[i] = value[i];
                }
            }
        }

        public uint TsNumberLayers
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_number_layers;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ts_number_layers = value;
            }
        }

        public uint[] TsTargetBitrate
        {
            get
            {
                uint[] __value = null;
                if (((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_target_bitrate != null)
                {
                    __value = new uint[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_target_bitrate[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ts_target_bitrate[i] = value[i];
                }
            }
        }

        public uint[] TsRateDecimator
        {
            get
            {
                uint[] __value = null;
                if (((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_rate_decimator != null)
                {
                    __value = new uint[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_rate_decimator[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ts_rate_decimator[i] = value[i];
                }
            }
        }

        public uint TsPeriodicity
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_periodicity;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ts_periodicity = value;
            }
        }

        public uint[] TsLayerId
        {
            get
            {
                uint[] __value = null;
                if (((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_layer_id != null)
                {
                    __value = new uint[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->ts_layer_id[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->ts_layer_id[i] = value[i];
                }
            }
        }

        public uint[] LayerTargetBitrate
        {
            get
            {
                uint[] __value = null;
                if (((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->layer_target_bitrate != null)
                {
                    __value = new uint[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->layer_target_bitrate[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->layer_target_bitrate[i] = value[i];
                }
            }
        }

        public int TemporalLayeringMode
        {
            get
            {
                return ((global::vpxmd.VpxCodecEncCfg.__Internal*) __Instance)->temporal_layering_mode;
            }

            set
            {
                ((global::vpxmd.VpxCodecEncCfg.__Internal*)__Instance)->temporal_layering_mode = value;
            }
        }
    }

    /// <summary>vp9 svc extra configure parameters</summary>
    /// <remarks>This defines max/min quantizers and scale factors for each layer</remarks>
    public unsafe partial class VpxSvcParameters : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 244)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed int max_quantizers[12];

            [FieldOffset(48)]
            internal fixed int min_quantizers[12];

            [FieldOffset(96)]
            internal fixed int scaling_factor_num[12];

            [FieldOffset(144)]
            internal fixed int scaling_factor_den[12];

            [FieldOffset(192)]
            internal fixed int speed_per_layer[12];

            [FieldOffset(240)]
            internal int temporal_layering_mode;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_svc_parameters@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcParameters> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcParameters>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxSvcParameters __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcParameters(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxSvcParameters __CreateInstance(global::vpxmd.VpxSvcParameters.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcParameters(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxSvcParameters.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcParameters.__Internal));
            *(global::vpxmd.VpxSvcParameters.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcParameters(global::vpxmd.VpxSvcParameters.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxSvcParameters(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxSvcParameters()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcParameters.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxSvcParameters(global::vpxmd.VpxSvcParameters _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcParameters.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxSvcParameters.__Internal*) __Instance) = *((global::vpxmd.VpxSvcParameters.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxSvcParameters __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] MaxQuantizers
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->max_quantizers != null)
                {
                    __value = new int[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = ((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->max_quantizers[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((global::vpxmd.VpxSvcParameters.__Internal*)__Instance)->max_quantizers[i] = value[i];
                }
            }
        }

        public int[] MinQuantizers
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->min_quantizers != null)
                {
                    __value = new int[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = ((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->min_quantizers[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((global::vpxmd.VpxSvcParameters.__Internal*)__Instance)->min_quantizers[i] = value[i];
                }
            }
        }

        public int[] ScalingFactorNum
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->scaling_factor_num != null)
                {
                    __value = new int[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = ((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->scaling_factor_num[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((global::vpxmd.VpxSvcParameters.__Internal*)__Instance)->scaling_factor_num[i] = value[i];
                }
            }
        }

        public int[] ScalingFactorDen
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->scaling_factor_den != null)
                {
                    __value = new int[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = ((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->scaling_factor_den[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((global::vpxmd.VpxSvcParameters.__Internal*)__Instance)->scaling_factor_den[i] = value[i];
                }
            }
        }

        public int[] SpeedPerLayer
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->speed_per_layer != null)
                {
                    __value = new int[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = ((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->speed_per_layer[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((global::vpxmd.VpxSvcParameters.__Internal*)__Instance)->speed_per_layer[i] = value[i];
                }
            }
        }

        public int TemporalLayeringMode
        {
            get
            {
                return ((global::vpxmd.VpxSvcParameters.__Internal*) __Instance)->temporal_layering_mode;
            }

            set
            {
                ((global::vpxmd.VpxSvcParameters.__Internal*)__Instance)->temporal_layering_mode = value;
            }
        }
    }

    public unsafe partial class vpx_encoder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_enc_init_ver")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecEncInitVer(global::System.IntPtr ctx, global::System.IntPtr iface, global::System.IntPtr cfg, int flags, int ver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_enc_init_multi_ver")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecEncInitMultiVer(global::System.IntPtr ctx, global::System.IntPtr iface, global::System.IntPtr cfg, int num_enc, int flags, global::System.IntPtr dsf, int ver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_enc_config_default")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecEncConfigDefault(global::System.IntPtr iface, global::System.IntPtr cfg, uint usage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_enc_config_set")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecEncConfigSet(global::System.IntPtr ctx, global::System.IntPtr cfg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_get_global_headers")]
            internal static extern global::System.IntPtr VpxCodecGetGlobalHeaders(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_encode")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecEncode(global::System.IntPtr ctx, global::System.IntPtr img, long pts, uint duration, int flags, uint deadline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_set_cx_data_buf")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecSetCxDataBuf(global::System.IntPtr ctx, global::System.IntPtr buf, uint pad_before, uint pad_after);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_get_cx_data")]
            internal static extern global::System.IntPtr VpxCodecGetCxData(global::System.IntPtr ctx, void** iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_get_preview_frame")]
            internal static extern global::System.IntPtr VpxCodecGetPreviewFrame(global::System.IntPtr ctx);
        }

        /// <summary>Initialize an encoder instance</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration to use, if known. May be NULL.</param>
        /// <param name="flags">Bitfield of VPX_CODEC_USE_* flags</param>
        /// <param name="ver">
        /// <para>ABI version number. Must be set to</para>
        /// <para>VPX_ENCODER_ABI_VERSION</para>
        /// </param>
        /// <remarks>
        /// <para>Initializes a encoder context using the given interface. Applications</para>
        /// <para>should call the vpx_codec_enc_init convenience macro instead of this</para>
        /// <para>function directly, to ensure that the ABI version number parameter</para>
        /// <para>is properly initialized.</para>
        /// <para>If the library was configured with --disable-multithread, this call</para>
        /// <para>is not thread safe and should be guarded with a lock if being used</para>
        /// <para>in a multithreaded context.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The decoder algorithm initialized.</para>
        /// <para>#VPX_CODEC_MEM_ERROR</para>
        /// <para>Memory allocation failed.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecEncInitVer(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxCodecIface iface, global::vpxmd.VpxCodecEncCfg cfg, int flags, int ver)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __arg2 = ReferenceEquals(cfg, null) ? global::System.IntPtr.Zero : cfg.__Instance;
            var __ret = __Internal.VpxCodecEncInitVer(__arg0, __arg1, __arg2, flags, ver);
            return __ret;
        }

        /// <summary>Initialize multi-encoder instance</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration to use, if known. May be NULL.</param>
        /// <param name="num_enc">Total number of encoders.</param>
        /// <param name="flags">Bitfield of VPX_CODEC_USE_* flags</param>
        /// <param name="dsf">Pointer to down-sampling factors.</param>
        /// <param name="ver">
        /// <para>ABI version number. Must be set to</para>
        /// <para>VPX_ENCODER_ABI_VERSION</para>
        /// </param>
        /// <remarks>
        /// <para>Initializes multi-encoder context using the given interface.</para>
        /// <para>Applications should call the vpx_codec_enc_init_multi convenience macro</para>
        /// <para>instead of this function directly, to ensure that the ABI version number</para>
        /// <para>parameter is properly initialized.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The decoder algorithm initialized.</para>
        /// <para>#VPX_CODEC_MEM_ERROR</para>
        /// <para>Memory allocation failed.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecEncInitMultiVer(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxCodecIface iface, global::vpxmd.VpxCodecEncCfg cfg, int num_enc, int flags, global::vpxmd.VpxRational dsf, int ver)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __arg2 = ReferenceEquals(cfg, null) ? global::System.IntPtr.Zero : cfg.__Instance;
            var __arg5 = ReferenceEquals(dsf, null) ? global::System.IntPtr.Zero : dsf.__Instance;
            var __ret = __Internal.VpxCodecEncInitMultiVer(__arg0, __arg1, __arg2, num_enc, flags, __arg5, ver);
            return __ret;
        }

        /// <summary>Get a default configuration</summary>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration buffer to populate.</param>
        /// <param name="usage">Must be set to 0.</param>
        /// <remarks>
        /// <para>Initializes a encoder configuration structure with default values. Supports</para>
        /// <para>the notion of &quot;usages&quot; so that an algorithm may offer different default</para>
        /// <para>settings depending on the user's intended goal. This function</para>
        /// <para>be called by all applications to initialize the configuration structure</para>
        /// <para>before specializing the configuration with application specific values.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The configuration was populated.</para>
        /// <para>#VPX_CODEC_INCAPABLE</para>
        /// <para>Interface is not an encoder interface.</para>
        /// <para>#VPX_CODEC_INVALID_PARAM</para>
        /// <para>A parameter was NULL, or the usage value was not recognized.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecEncConfigDefault(global::vpxmd.VpxCodecIface iface, global::vpxmd.VpxCodecEncCfg cfg, uint usage)
        {
            var __arg0 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __arg1 = ReferenceEquals(cfg, null) ? global::System.IntPtr.Zero : cfg.__Instance;
            var __ret = __Internal.VpxCodecEncConfigDefault(__arg0, __arg1, usage);
            return __ret;
        }

        /// <summary>Set or change configuration</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cfg">Configuration buffer to use</param>
        /// <remarks>
        /// <para>Reconfigures an encoder instance according to the given configuration.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The configuration was populated.</para>
        /// <para>#VPX_CODEC_INCAPABLE</para>
        /// <para>Interface is not an encoder interface.</para>
        /// <para>#VPX_CODEC_INVALID_PARAM</para>
        /// <para>A parameter was NULL, or the usage value was not recognized.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecEncConfigSet(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxCodecEncCfg cfg)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(cfg, null) ? global::System.IntPtr.Zero : cfg.__Instance;
            var __ret = __Internal.VpxCodecEncConfigSet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get global stream headers</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <remarks>
        /// <para>Retrieves a stream level global header packet, if supported by the codec.</para>
        /// <para>NULL</para>
        /// <para>Encoder does not support global header</para>
        /// <para>Non-NULL</para>
        /// <para>Pointer to buffer containing global header packet</para>
        /// </remarks>
        public static global::vpxmd.VpxFixedBuf VpxCodecGetGlobalHeaders(global::vpxmd.VpxCodecCtx ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecGetGlobalHeaders(__arg0);
            global::vpxmd.VpxFixedBuf __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxFixedBuf.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxFixedBuf) global::vpxmd.VpxFixedBuf.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxFixedBuf.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Encode a frame</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="img">Image data to encode, NULL to flush.</param>
        /// <param name="pts">Presentation time stamp, in timebase units.</param>
        /// <param name="duration">Duration to show frame, in timebase units.</param>
        /// <param name="flags">Flags to use for encoding this frame.</param>
        /// <param name="deadline">Time to spend encoding, in microseconds. (0=infinite)</param>
        /// <remarks>
        /// <para>Encodes a video frame at the given &quot;presentation time.&quot; The presentation</para>
        /// <para>time stamp (PTS)</para>
        /// <para>The encoder supports the notion of a soft real-time deadline. Given a</para>
        /// <para>non-zero value to the deadline parameter, the encoder will make a &quot;best</para>
        /// <para>effort&quot; guarantee to  return before the given time slice expires. It is</para>
        /// <para>implicit that limiting the available time to encode will degrade the</para>
        /// <para>output quality. The encoder can be given an unlimited time to produce the</para>
        /// <para>best possible frame by specifying a deadline of '0'. This deadline</para>
        /// <para>supersedes the VPx notion of &quot;best quality, good quality, realtime&quot;.</para>
        /// <para>Applications that wish to map these former settings to the new deadline</para>
        /// <para>based system can use the symbols #VPX_DL_REALTIME, #VPX_DL_GOOD_QUALITY,</para>
        /// <para>and #VPX_DL_BEST_QUALITY.</para>
        /// <para>When the last frame has been passed to the encoder, this function should</para>
        /// <para>continue to be called, with the img parameter set to NULL. This will</para>
        /// <para>signal the end-of-stream condition to the encoder and allow it to encode</para>
        /// <para>any held buffers. Encoding is complete when vpx_codec_encode() is called</para>
        /// <para>and vpx_codec_get_cx_data() returns no data.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The configuration was populated.</para>
        /// <para>#VPX_CODEC_INCAPABLE</para>
        /// <para>Interface is not an encoder interface.</para>
        /// <para>#VPX_CODEC_INVALID_PARAM</para>
        /// <para>A parameter was NULL, the image format is unsupported, etc.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecEncode(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxImage img, long pts, uint duration, int flags, uint deadline)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(img, null) ? global::System.IntPtr.Zero : img.__Instance;
            var __ret = __Internal.VpxCodecEncode(__arg0, __arg1, pts, duration, flags, deadline);
            return __ret;
        }

        /// <summary>Set compressed data output buffer</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="buf">Buffer to store compressed data into</param>
        /// <param name="pad_before">Bytes to skip before writing compressed data</param>
        /// <param name="pad_after">Bytes to skip after writing compressed data</param>
        /// <remarks>
        /// <para>Sets the buffer that the codec should output the compressed data</para>
        /// <para>into. This call effectively sets the buffer pointer returned in the</para>
        /// <para>next VPX_CODEC_CX_FRAME_PKT packet. Subsequent packets will be</para>
        /// <para>appended into this buffer. The buffer is preserved across frames,</para>
        /// <para>so applications must periodically call this function after flushing</para>
        /// <para>the accumulated compressed data to disk or to the network to reset</para>
        /// <para>the pointer to the buffer's head.</para>
        /// <para>`pad_before` bytes will be skipped before writing the compressed</para>
        /// <para>data, and `pad_after` bytes will be appended to the packet. The size</para>
        /// <para>of the packet will be the sum of the size of the actual compressed</para>
        /// <para>data, pad_before, and pad_after. The padding bytes will be preserved</para>
        /// <para>(not overwritten).</para>
        /// <para>Note that calling this function does not guarantee that the returned</para>
        /// <para>compressed data will be placed into the specified buffer. In the</para>
        /// <para>event that the encoded data will not fit into the buffer provided,</para>
        /// <para>the returned packet</para>
        /// <para>if this call were never used. In this event, the output packet will</para>
        /// <para>NOT have any padding, and the application must free space and copy it</para>
        /// <para>to the proper place. This is of particular note in configurations</para>
        /// <para>that may output multiple packets for a single encoded frame (e.g., lagged</para>
        /// <para>encoding) or if the application does not reset the buffer periodically.</para>
        /// <para>Applications may restore the default behavior of the codec providing</para>
        /// <para>the compressed data buffer by calling this function with a NULL</para>
        /// <para>buffer.</para>
        /// <para>Applications</para>
        /// <para>vpx_codec_get_cx_data().</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The buffer was set successfully.</para>
        /// <para>#VPX_CODEC_INVALID_PARAM</para>
        /// <para>A parameter was NULL, the image format is unsupported, etc.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecSetCxDataBuf(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxFixedBuf buf, uint pad_before, uint pad_after)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(buf, null) ? global::System.IntPtr.Zero : buf.__Instance;
            var __ret = __Internal.VpxCodecSetCxDataBuf(__arg0, __arg1, pad_before, pad_after);
            return __ret;
        }

        /// <summary>Encoded data iterator</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="iter">Iterator storage, initialized to NULL</param>
        /// <returns>
        /// <para>Returns a pointer to an output data packet (compressed frame data,</para>
        /// <para>two-pass statistics, etc.) or NULL to signal end-of-list.</para>
        /// </returns>
        /// <remarks>
        /// <para>Iterates over a list of data packets to be passed from the encoder to the</para>
        /// <para>application. The different kinds of packets available are enumerated in</para>
        /// <para>#vpx_codec_cx_pkt_kind.</para>
        /// <para>#VPX_CODEC_CX_FRAME_PKT packets should be passed to the application's</para>
        /// <para>muxer. Multiple compressed frames may be in the list.</para>
        /// <para>#VPX_CODEC_STATS_PKT packets should be appended to a global buffer.</para>
        /// <para>The application</para>
        /// <para>not recognize or support.</para>
        /// <para>The data buffers returned from this function are only guaranteed to be</para>
        /// <para>valid until the application makes another call to any vpx_codec_* function.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecCxPkt VpxCodecGetCxData(global::vpxmd.VpxCodecCtx ctx, void** iter)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecGetCxData(__arg0, iter);
            global::vpxmd.VpxCodecCxPkt __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxCodecCxPkt.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxCodecCxPkt) global::vpxmd.VpxCodecCxPkt.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxCodecCxPkt.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get Preview Frame</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <returns>
        /// <para>Returns a pointer to a preview image, or NULL if no image is</para>
        /// <para>available.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns an image that can be used as a preview. Shows the image as it would</para>
        /// <para>exist at the decompressor. The application</para>
        /// <para>image buffer.</para>
        /// </remarks>
        public static global::vpxmd.VpxImage VpxCodecGetPreviewFrame(global::vpxmd.VpxCodecCtx ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecGetPreviewFrame(__arg0);
            global::vpxmd.VpxImage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxImage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxImage) global::vpxmd.VpxImage.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxImage.__CreateInstance(__ret);
            return __result0;
        }
    }

    /// <summary>Algorithm return codes</summary>
    public enum VpxCodecErrT
    {
        /// <summary>Operation completed without error</summary>
        VPX_CODEC_OK = 0,
        /// <summary>Unspecified error</summary>
        VPX_CODEC_ERROR = 1,
        /// <summary>Memory operation failed</summary>
        VPX_CODEC_MEM_ERROR = 2,
        /// <summary>ABI version mismatch</summary>
        VPX_CODEC_ABI_MISMATCH = 3,
        /// <summary>Algorithm does not have required capability</summary>
        VPX_CODEC_INCAPABLE = 4,
        /// <summary>The given bitstream is not supported.</summary>
        /// <remarks>
        /// <para>The bitstream was unable to be parsed at the highest level. The decoder</para>
        /// <para>is unable to proceed. This error</para>
        /// <para>stream.</para>
        /// </remarks>
        VPX_CODEC_UNSUP_BITSTREAM = 5,
        /// <summary>Encoded bitstream uses an unsupported feature</summary>
        /// <remarks>
        /// <para>The decoder does not implement a feature required by the encoder. This</para>
        /// <para>return code should only be used for features that prevent future</para>
        /// <para>pictures from being properly decoded. This error</para>
        /// <para>fatal to the stream or</para>
        /// </remarks>
        VPX_CODEC_UNSUP_FEATURE = 6,
        /// <summary>The coded data for this stream is corrupt or incomplete</summary>
        /// <remarks>
        /// <para>There was a problem decoding the current frame.  This return code</para>
        /// <para>should only be used for failures that prevent future pictures from</para>
        /// <para>being properly decoded. This error</para>
        /// <para>stream or</para>
        /// <para>is continued for the current GOP, artifacts may be present.</para>
        /// </remarks>
        VPX_CODEC_CORRUPT_FRAME = 7,
        /// <summary>An application-supplied parameter is not valid.</summary>
        VPX_CODEC_INVALID_PARAM = 8,
        /// <summary>An iterator reached the end of list.</summary>
        VPX_CODEC_LIST_END = 9
    }

    /// <summary>
    /// <para>Bit depth for codec</para>
    /// <para>*</para>
    /// <para>This enumeration determines the bit depth of the codec.</para>
    /// </summary>
    public enum VpxBitDepth
    {
        /// <summary>8 bits</summary>
        VPX_BITS_8 = 8,
        /// <summary>10 bits</summary>
        VPX_BITS_10 = 10,
        /// <summary>12 bits</summary>
        VPX_BITS_12 = 12
    }

    /// <summary>Algorithm return codes</summary>
    /// <summary>Codec capabilities bitfield</summary>
    /// <remarks>
    /// <para>Each codec advertises the capabilities it supports as part of its</para>
    /// <para>::vpx_codec_iface_t interface structure. Capabilities are extra interfaces</para>
    /// <para>or functionality, and are not required to be supported.</para>
    /// <para>The available flags are specified by VPX_CODEC_CAP_* defines.</para>
    /// </remarks>
    /// <summary>Initialization-time Feature Enabling</summary>
    /// <remarks>
    /// <para>Certain codec features must be known at initialization time, to allow for</para>
    /// <para>proper memory allocation.</para>
    /// <para>The available flags are specified by VPX_CODEC_USE_* defines.</para>
    /// </remarks>
    /// <summary>Codec interface structure.</summary>
    /// <remarks>
    /// <para>Contains function pointers and other data private to the codec</para>
    /// <para>implementation. This structure is opaque to the application.</para>
    /// </remarks>
    /// <summary>Codec private data structure.</summary>
    /// <remarks>
    /// <para>Contains data private to the codec implementation. This structure is opaque</para>
    /// <para>to the application.</para>
    /// </remarks>
    /// <summary>Iterator</summary>
    /// <remarks>Opaque storage used for iterating over lists.</remarks>
    /// <summary>
    /// <para>Bit depth for codec</para>
    /// <para>*</para>
    /// <para>This enumeration determines the bit depth of the codec.</para>
    /// </summary>
    /// <summary>Codec context structure</summary>
    /// <remarks>
    /// <para>All codecs</para>
    /// <para>this data should be considered private to the codec algorithm, and</para>
    /// <para>not be manipulated or examined by the calling application. Applications</para>
    /// <para>may reference the 'name' member to get a printable description of the</para>
    /// <para>algorithm.</para>
    /// </remarks>
    public unsafe partial class VpxCodecIface
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecIface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecIface>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecIface __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecIface(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecIface __CreateInstance(global::vpxmd.VpxCodecIface.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecIface(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecIface.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecIface.__Internal));
            *(global::vpxmd.VpxCodecIface.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecIface(global::vpxmd.VpxCodecIface.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecIface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class VpxCodecPriv
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecPriv> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecPriv>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecPriv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecPriv(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecPriv __CreateInstance(global::vpxmd.VpxCodecPriv.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecPriv(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecPriv.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecPriv.__Internal));
            *(global::vpxmd.VpxCodecPriv.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecPriv(global::vpxmd.VpxCodecPriv.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecPriv(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Codec context structure</summary>
    /// <remarks>
    /// <para>All codecs</para>
    /// <para>this data should be considered private to the codec algorithm, and</para>
    /// <para>not be manipulated or examined by the calling application. Applications</para>
    /// <para>may reference the 'name' member to get a printable description of the</para>
    /// <para>algorithm.</para>
    /// </remarks>
    public unsafe partial class VpxCodecCtx : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr name;

            [FieldOffset(8)]
            internal global::System.IntPtr iface;

            [FieldOffset(16)]
            internal global::vpxmd.VpxCodecErrT err;

            [FieldOffset(24)]
            internal global::System.IntPtr err_detail;

            [FieldOffset(32)]
            internal int init_flags;

            [FieldOffset(40)]
            internal global::vpxmd.VpxCodecCtx.Config.__Internal config;

            [FieldOffset(48)]
            internal global::System.IntPtr priv;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_codec_ctx@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public unsafe partial struct Config
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr dec;

                [FieldOffset(0)]
                internal global::System.IntPtr enc;

                [FieldOffset(0)]
                internal global::System.IntPtr raw;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0<unnamed-type-config>@vpx_codec_ctx@@QEAA@AEBT01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
            }

            private Config.__Internal __instance;
            internal Config.__Internal __Instance { get { return __instance; } }

            internal static global::vpxmd.VpxCodecCtx.Config __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::vpxmd.VpxCodecCtx.Config(native.ToPointer(), skipVTables);
            }

            internal static global::vpxmd.VpxCodecCtx.Config __CreateInstance(global::vpxmd.VpxCodecCtx.Config.__Internal native, bool skipVTables = false)
            {
                return new global::vpxmd.VpxCodecCtx.Config(native, skipVTables);
            }

            private Config(global::vpxmd.VpxCodecCtx.Config.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Config(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::vpxmd.VpxCodecCtx.Config.__Internal*) native;
            }

            public Config(global::vpxmd.VpxCodecCtx.Config _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            public global::vpxmd.VpxCodecDecCfg Dec
            {
                get
                {
                    global::vpxmd.VpxCodecDecCfg __result0;
                    if (__instance.dec == IntPtr.Zero) __result0 = null;
                    else if (global::vpxmd.VpxCodecDecCfg.NativeToManagedMap.ContainsKey(__instance.dec))
                        __result0 = (global::vpxmd.VpxCodecDecCfg) global::vpxmd.VpxCodecDecCfg.NativeToManagedMap[__instance.dec];
                    else __result0 = global::vpxmd.VpxCodecDecCfg.__CreateInstance(__instance.dec);
                    return __result0;
                }
            }

            public global::vpxmd.VpxCodecEncCfg Enc
            {
                get
                {
                    global::vpxmd.VpxCodecEncCfg __result0;
                    if (__instance.enc == IntPtr.Zero) __result0 = null;
                    else if (global::vpxmd.VpxCodecEncCfg.NativeToManagedMap.ContainsKey(__instance.enc))
                        __result0 = (global::vpxmd.VpxCodecEncCfg) global::vpxmd.VpxCodecEncCfg.NativeToManagedMap[__instance.enc];
                    else __result0 = global::vpxmd.VpxCodecEncCfg.__CreateInstance(__instance.enc);
                    return __result0;
                }
            }

            public global::System.IntPtr Raw
            {
                get
                {
                    return __instance.raw;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCtx> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecCtx>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecCtx __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecCtx(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecCtx __CreateInstance(global::vpxmd.VpxCodecCtx.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecCtx(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecCtx.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCtx.__Internal));
            *(global::vpxmd.VpxCodecCtx.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecCtx(global::vpxmd.VpxCodecCtx.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecCtx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxCodecCtx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCtx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxCodecCtx(global::vpxmd.VpxCodecCtx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecCtx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxCodecCtx.__Internal*) __Instance) = *((global::vpxmd.VpxCodecCtx.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxCodecCtx __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                if (((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->name == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->name;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->name, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::vpxmd.VpxCodecCtx.__Internal*)__Instance)->name = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public global::vpxmd.VpxCodecIface Iface
        {
            get
            {
                global::vpxmd.VpxCodecIface __result0;
                if (((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->iface == IntPtr.Zero) __result0 = null;
                else if (global::vpxmd.VpxCodecIface.NativeToManagedMap.ContainsKey(((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->iface))
                    __result0 = (global::vpxmd.VpxCodecIface) global::vpxmd.VpxCodecIface.NativeToManagedMap[((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->iface];
                else __result0 = global::vpxmd.VpxCodecIface.__CreateInstance(((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->iface);
                return __result0;
            }

            set
            {
                ((global::vpxmd.VpxCodecCtx.__Internal*)__Instance)->iface = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::vpxmd.VpxCodecErrT Err
        {
            get
            {
                return ((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->err;
            }

            set
            {
                ((global::vpxmd.VpxCodecCtx.__Internal*)__Instance)->err = value;
            }
        }

        public string ErrDetail
        {
            get
            {
                if (((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->err_detail == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->err_detail;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->err_detail, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::vpxmd.VpxCodecCtx.__Internal*)__Instance)->err_detail = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public int InitFlags
        {
            get
            {
                return ((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->init_flags;
            }

            set
            {
                ((global::vpxmd.VpxCodecCtx.__Internal*)__Instance)->init_flags = value;
            }
        }

        public global::vpxmd.VpxCodecCtx.Config config
        {
            get
            {
                return global::vpxmd.VpxCodecCtx.Config.__CreateInstance(((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->config);
            }

            set
            {
                ((global::vpxmd.VpxCodecCtx.__Internal*)__Instance)->config = value.__Instance;
            }
        }

        public global::vpxmd.VpxCodecPriv Priv
        {
            get
            {
                global::vpxmd.VpxCodecPriv __result0;
                if (((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->priv == IntPtr.Zero) __result0 = null;
                else if (global::vpxmd.VpxCodecPriv.NativeToManagedMap.ContainsKey(((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->priv))
                    __result0 = (global::vpxmd.VpxCodecPriv) global::vpxmd.VpxCodecPriv.NativeToManagedMap[((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->priv];
                else __result0 = global::vpxmd.VpxCodecPriv.__CreateInstance(((global::vpxmd.VpxCodecCtx.__Internal*) __Instance)->priv);
                return __result0;
            }

            set
            {
                ((global::vpxmd.VpxCodecCtx.__Internal*)__Instance)->priv = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class vpx_codec
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_version")]
            internal static extern int VpxCodecVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_version_str")]
            internal static extern global::System.IntPtr VpxCodecVersionStr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_version_extra_str")]
            internal static extern global::System.IntPtr VpxCodecVersionExtraStr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_build_config")]
            internal static extern global::System.IntPtr VpxCodecBuildConfig();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_iface_name")]
            internal static extern global::System.IntPtr VpxCodecIfaceName(global::System.IntPtr iface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_err_to_string")]
            internal static extern global::System.IntPtr VpxCodecErrToString(global::vpxmd.VpxCodecErrT err);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_error")]
            internal static extern global::System.IntPtr VpxCodecError(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_error_detail")]
            internal static extern global::System.IntPtr VpxCodecErrorDetail(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_destroy")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecDestroy(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_get_caps")]
            internal static extern int VpxCodecGetCaps(global::System.IntPtr iface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_control_")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControl(global::System.IntPtr ctx, int ctrl_id);
        }

        /// <summary>Return the version information (as an integer)</summary>
        /// <remarks>
        /// <para>Returns a packed encoding of the library version number. This will only</para>
        /// <para>include</para>
        /// <para>the major.minor.patch component of the version number. Note that this encoded</para>
        /// <para>value should be accessed through the macros provided, as the encoding may</para>
        /// <para>change</para>
        /// <para>in the future.</para>
        /// </remarks>
        public static int VpxCodecVersion()
        {
            var __ret = __Internal.VpxCodecVersion();
            return __ret;
        }

        /// <summary>Return the version information (as a string)</summary>
        /// <remarks>
        /// <para>Returns a printable string containing the full library version number. This</para>
        /// <para>may</para>
        /// <para>contain additional text following the three digit version number, as to</para>
        /// <para>indicate</para>
        /// <para>release candidates, prerelease versions, etc.</para>
        /// </remarks>
        public static string VpxCodecVersionStr()
        {
            var __ret = __Internal.VpxCodecVersionStr();
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        /// <summary>Return the version information (as a string)</summary>
        /// <remarks>
        /// <para>Returns a printable &quot;extra string&quot;. This is the component of the string</para>
        /// <para>returned</para>
        /// <para>by vpx_codec_version_str() following the three digit version number.</para>
        /// </remarks>
        public static string VpxCodecVersionExtraStr()
        {
            var __ret = __Internal.VpxCodecVersionExtraStr();
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        /// <summary>Return the build configuration</summary>
        /// <remarks>
        /// <para>Returns a printable string containing an encoded version of the build</para>
        /// <para>configuration. This may be useful to vpx support.</para>
        /// </remarks>
        public static string VpxCodecBuildConfig()
        {
            var __ret = __Internal.VpxCodecBuildConfig();
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        /// <summary>Return the name for a given interface</summary>
        /// <param name="iface">Interface pointer</param>
        /// <remarks>Returns a human readable string for name of the given codec interface.</remarks>
        public static string VpxCodecIfaceName(global::vpxmd.VpxCodecIface iface)
        {
            var __arg0 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __ret = __Internal.VpxCodecIfaceName(__arg0);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        /// <summary>Convert error number to printable string</summary>
        /// <param name="err">Error number.</param>
        /// <remarks>
        /// <para>Returns a human readable string for the last error returned by the</para>
        /// <para>algorithm. The returned error will be one line and will not contain</para>
        /// <para>any newline characters.</para>
        /// </remarks>
        public static string VpxCodecErrToString(global::vpxmd.VpxCodecErrT err)
        {
            var __ret = __Internal.VpxCodecErrToString(err);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        /// <summary>Retrieve error synopsis for codec context</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <remarks>
        /// <para>Returns a human readable string for the last error returned by the</para>
        /// <para>algorithm. The returned error will be one line and will not contain</para>
        /// <para>any newline characters.</para>
        /// </remarks>
        public static string VpxCodecError(global::vpxmd.VpxCodecCtx ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecError(__arg0);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        /// <summary>Retrieve detailed error information for codec context</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <remarks>
        /// <para>Returns a human readable string providing detailed information about</para>
        /// <para>the last error.</para>
        /// <para>NULL</para>
        /// <para>No detailed information is available.</para>
        /// </remarks>
        public static string VpxCodecErrorDetail(global::vpxmd.VpxCodecCtx ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecErrorDetail(__arg0);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        /// <summary>Destroy a codec instance</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <remarks>
        /// <para>Destroys a codec context, freeing any associated memory buffers.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The codec algorithm initialized.</para>
        /// <para>#VPX_CODEC_MEM_ERROR</para>
        /// <para>Memory allocation failed.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecDestroy(global::vpxmd.VpxCodecCtx ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecDestroy(__arg0);
            return __ret;
        }

        /// <summary>Get the capabilities of an algorithm.</summary>
        /// <param name="iface">Pointer to the algorithm interface</param>
        /// <remarks>Retrieves the capabilities bitfield from the algorithm's interface.</remarks>
        public static int VpxCodecGetCaps(global::vpxmd.VpxCodecIface iface)
        {
            var __arg0 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __ret = __Internal.VpxCodecGetCaps(__arg0);
            return __ret;
        }

        /// <summary>Control algorithm</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="ctrl_id">Algorithm specific control identifier</param>
        /// <remarks>
        /// <para>This function is used to exchange algorithm specific data with the codec</para>
        /// <para>instance. This can be used to implement features specific to a particular</para>
        /// <para>algorithm.</para>
        /// <para>This wrapper function dispatches the request to the helper function</para>
        /// <para>associated with the given ctrl_id. It tries to call this function</para>
        /// <para>transparently, but will return #VPX_CODEC_ERROR if the request could not</para>
        /// <para>be dispatched.</para>
        /// <para>Note that this function should not be used directly. Call the</para>
        /// <para>#vpx_codec_control wrapper macro instead.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The control request was processed.</para>
        /// <para>#VPX_CODEC_ERROR</para>
        /// <para>The control request was not processed.</para>
        /// <para>#VPX_CODEC_INVALID_PARAM</para>
        /// <para>The data was not valid.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecControl(global::vpxmd.VpxCodecCtx ctx, int ctrl_id)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecControl(__arg0, ctrl_id);
            return __ret;
        }
    }

    /// <summary>List of supported image formats</summary>
    public enum VpxImgFmt
    {
        VPX_IMG_FMT_NONE = 0,
        VPX_IMG_FMT_YV12 = 769,
        VPX_IMG_FMT_I420 = 258,
        VPX_IMG_FMT_I422 = 261,
        VPX_IMG_FMT_I444 = 262,
        VPX_IMG_FMT_I440 = 263,
        VPX_IMG_FMT_NV12 = 265,
        VPX_IMG_FMT_I42016 = 2306,
        VPX_IMG_FMT_I42216 = 2309,
        VPX_IMG_FMT_I44416 = 2310,
        VPX_IMG_FMT_I44016 = 2311
    }

    /// <summary>List of supported color spaces</summary>
    public enum VpxColorSpace
    {
        /// <summary>Unknown</summary>
        VPX_CS_UNKNOWN = 0,
        /// <summary>BT.601</summary>
        VPX_CS_BT_601 = 1,
        /// <summary>BT.709</summary>
        VPX_CS_BT_709 = 2,
        /// <summary>SMPTE.170</summary>
        VPX_CS_SMPTE_170 = 3,
        /// <summary>SMPTE.240</summary>
        VPX_CS_SMPTE_240 = 4,
        /// <summary>BT.2020</summary>
        VPX_CS_BT_2020 = 5,
        /// <summary>Reserved</summary>
        VPX_CS_RESERVED = 6,
        /// <summary>sRGB</summary>
        VPX_CS_SRGB = 7
    }

    /// <summary>List of supported color range</summary>
    public enum VpxColorRange
    {
        /// <summary>Y [16..235], UV [16..240]</summary>
        VPX_CR_STUDIO_RANGE = 0,
        /// <summary>YUV/RGB [0..255]</summary>
        VPX_CR_FULL_RANGE = 1
    }

    /// <summary>List of supported image formats</summary>
    /// <summary>List of supported color spaces</summary>
    /// <summary>List of supported color range</summary>
    /// <summary>Image Descriptor</summary>
    /// <summary>Representation of a rectangle on a surface</summary>
    /// <summary>Image Descriptor</summary>
    public unsafe partial class VpxImage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::vpxmd.VpxImgFmt fmt;

            [FieldOffset(4)]
            internal global::vpxmd.VpxColorSpace cs;

            [FieldOffset(8)]
            internal global::vpxmd.VpxColorRange range;

            [FieldOffset(12)]
            internal uint w;

            [FieldOffset(16)]
            internal uint h;

            [FieldOffset(20)]
            internal uint bit_depth;

            [FieldOffset(24)]
            internal uint d_w;

            [FieldOffset(28)]
            internal uint d_h;

            [FieldOffset(32)]
            internal uint r_w;

            [FieldOffset(36)]
            internal uint r_h;

            [FieldOffset(40)]
            internal uint x_chroma_shift;

            [FieldOffset(44)]
            internal uint y_chroma_shift;

            [FieldOffset(48)]
            internal global::System.IntPtr planeY;

            [FieldOffset(56)]
            internal global::System.IntPtr planeU;

            [FieldOffset(64)]
            internal global::System.IntPtr planeV;

            [FieldOffset(72)]
            internal global::System.IntPtr planeT;

            [FieldOffset(80)]
            internal fixed int stride[4];

            [FieldOffset(96)]
            internal int bps;

            [FieldOffset(104)]
            internal global::System.IntPtr user_priv;

            [FieldOffset(112)]
            internal global::System.IntPtr img_data;

            [FieldOffset(120)]
            internal int img_data_owner;

            [FieldOffset(124)]
            internal int self_allocd;

            [FieldOffset(128)]
            internal global::System.IntPtr fb_priv;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_image@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_img_alloc")]
            internal static extern global::System.IntPtr VpxImgAlloc(global::System.IntPtr img, global::vpxmd.VpxImgFmt fmt, uint d_w, uint d_h, uint align);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_img_wrap")]
            internal static extern global::System.IntPtr VpxImgWrap(global::System.IntPtr img, global::vpxmd.VpxImgFmt fmt, uint d_w, uint d_h, uint stride_align, byte* img_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_img_set_rect")]
            internal static extern int VpxImgSetRect(global::System.IntPtr img, uint x, uint y, uint w, uint h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_img_flip")]
            internal static extern void VpxImgFlip(global::System.IntPtr img);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_img_free")]
            internal static extern void VpxImgFree(global::System.IntPtr img);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxImage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxImage>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxImage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxImage(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxImage __CreateInstance(global::vpxmd.VpxImage.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxImage(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxImage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxImage.__Internal));
            *(global::vpxmd.VpxImage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxImage(global::vpxmd.VpxImage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxImage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxImage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxImage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxImage(global::vpxmd.VpxImage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxImage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxImage.__Internal*) __Instance) = *((global::vpxmd.VpxImage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxImage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Open a descriptor, allocating storage for the underlying image</summary>
        /// <param name="img">
        /// <para>Pointer to storage for descriptor. If this parameter</para>
        /// <para>is NULL, the storage for the descriptor will be</para>
        /// <para>allocated on the heap.</para>
        /// </param>
        /// <param name="fmt">Format for the image</param>
        /// <param name="d_w">Width of the image</param>
        /// <param name="d_h">Height of the image</param>
        /// <param name="align">
        /// <para>Alignment, in bytes, of the image buffer and</para>
        /// <para>each row in the image(stride).</para>
        /// </param>
        /// <returns>
        /// <para>Returns a pointer to the initialized image descriptor. If the img</para>
        /// <para>parameter is non-null, the value of the img parameter will be</para>
        /// <para>returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a descriptor for storing an image of the given format. The</para>
        /// <para>storage for the descriptor is allocated on the heap.</para>
        /// </remarks>
        public static global::vpxmd.VpxImage VpxImgAlloc(global::vpxmd.VpxImage img, global::vpxmd.VpxImgFmt fmt, uint d_w, uint d_h, uint align)
        {
            var __arg0 = ReferenceEquals(img, null) ? global::System.IntPtr.Zero : img.__Instance;
            var __ret = __Internal.VpxImgAlloc(__arg0, fmt, d_w, d_h, align);
            global::vpxmd.VpxImage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxImage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxImage) global::vpxmd.VpxImage.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxImage.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Open a descriptor, using existing storage for the underlying image</summary>
        /// <param name="img">
        /// <para>Pointer to storage for descriptor. If this</para>
        /// <para>parameter is NULL, the storage for the descriptor</para>
        /// <para>will be allocated on the heap.</para>
        /// </param>
        /// <param name="fmt">Format for the image</param>
        /// <param name="d_w">Width of the image</param>
        /// <param name="d_h">Height of the image</param>
        /// <param name="stride_align">Alignment, in bytes, of each row in the image.</param>
        /// <param name="img_data">Storage to use for the image</param>
        /// <returns>
        /// <para>Returns a pointer to the initialized image descriptor. If the img</para>
        /// <para>parameter is non-null, the value of the img parameter will be</para>
        /// <para>returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a descriptor for storing an image of the given format. The</para>
        /// <para>storage for descriptor has been allocated elsewhere, and a descriptor is</para>
        /// <para>desired to &quot;wrap&quot; that storage.</para>
        /// </remarks>
        public static global::vpxmd.VpxImage VpxImgWrap(global::vpxmd.VpxImage img, global::vpxmd.VpxImgFmt fmt, uint d_w, uint d_h, uint stride_align, byte* img_data)
        {
            var __arg0 = ReferenceEquals(img, null) ? global::System.IntPtr.Zero : img.__Instance;
            var __ret = __Internal.VpxImgWrap(__arg0, fmt, d_w, d_h, stride_align, img_data);
            global::vpxmd.VpxImage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxImage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxImage) global::vpxmd.VpxImage.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxImage.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set the rectangle identifying the displayed portion of the image</summary>
        /// <param name="img">Image descriptor</param>
        /// <param name="x">leftmost column</param>
        /// <param name="y">topmost row</param>
        /// <param name="w">width</param>
        /// <param name="h">height</param>
        /// <returns>0 if the requested rectangle is valid, nonzero otherwise.</returns>
        /// <remarks>
        /// <para>Updates the displayed rectangle (aka viewport) on the image surface to</para>
        /// <para>match the specified coordinates and size.</para>
        /// </remarks>
        public static int VpxImgSetRect(global::vpxmd.VpxImage img, uint x, uint y, uint w, uint h)
        {
            var __arg0 = ReferenceEquals(img, null) ? global::System.IntPtr.Zero : img.__Instance;
            var __ret = __Internal.VpxImgSetRect(__arg0, x, y, w, h);
            return __ret;
        }

        /// <summary>Flip the image vertically (top for bottom)</summary>
        /// <param name="img">Image descriptor</param>
        /// <remarks>
        /// <para>Adjusts the image descriptor's pointers and strides to make the image</para>
        /// <para>be referenced upside-down.</para>
        /// </remarks>
        public static void VpxImgFlip(global::vpxmd.VpxImage img)
        {
            var __arg0 = ReferenceEquals(img, null) ? global::System.IntPtr.Zero : img.__Instance;
            __Internal.VpxImgFlip(__arg0);
        }

        /// <summary>Close an image descriptor</summary>
        /// <param name="img">Image descriptor</param>
        /// <remarks>Frees all allocated storage associated with an image descriptor.</remarks>
        public static void VpxImgFree(global::vpxmd.VpxImage img)
        {
            var __arg0 = ReferenceEquals(img, null) ? global::System.IntPtr.Zero : img.__Instance;
            __Internal.VpxImgFree(__arg0);
        }

        public global::vpxmd.VpxImgFmt Fmt
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->fmt;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->fmt = value;
            }
        }

        public global::vpxmd.VpxColorSpace Cs
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->cs;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->cs = value;
            }
        }

        public global::vpxmd.VpxColorRange Range
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->range;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->range = value;
            }
        }

        public uint W
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->w = value;
            }
        }

        public uint H
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->h;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->h = value;
            }
        }

        public uint BitDepth
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->bit_depth;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->bit_depth = value;
            }
        }

        public uint DW
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->d_w;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->d_w = value;
            }
        }

        public uint DH
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->d_h;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->d_h = value;
            }
        }

        public uint RW
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->r_w;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->r_w = value;
            }
        }

        public uint RH
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->r_h;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->r_h = value;
            }
        }

        public uint XChromaShift
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->x_chroma_shift;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->x_chroma_shift = value;
            }
        }

        public uint YChromaShift
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->y_chroma_shift;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->y_chroma_shift = value;
            }
        }

        /// <summary>pointer to the top left pixel for each plane</summary>
        //private byte*[] __planes;

        //private bool __planesInitialised;
        //public byte*[] Planes
        //{
        //    get
        //    {
        //        if (!__planesInitialised)
        //        {
        //            //__planes = null;

        //            if (((global::vpxmd.VpxImage.__Internal*)__Instance)->planes != null)
        //            {
        //                __planes = new byte*[4];
        //                for (int i = 0; i < 4; i++)
        //                    __planes[i] = ((global::vpxmd.VpxImage.__Internal*)__Instance)->planes[i];
        //            }

        //            __planesInitialised = true;
        //        }
        //        return __planes;

        //        //byte*[] __value = null;
        //        //if (((global::vpxmd.VpxImage.__Internal*)__Instance)->planes != null)
        //        //{
        //        //    __value = new byte*[4];
        //        //    for (int i = 0; i < 4; i++)
        //        //        __value[i] = (byte*)((global::vpxmd.VpxImage.__Internal*)__Instance)->planes + i;
        //        //}
        //        //return __value;
        //    }

        //    set
        //    {
        //        __planes = value;
        //        if (!__planesInitialised)
        //        {
        //            __planesInitialised = true;
        //        }
        //    }
        //}

        public global::System.IntPtr PlaneY
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeY;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeY = (global::System.IntPtr)value;
            }
        }

        public global::System.IntPtr PlaneU
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeU;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeU = (global::System.IntPtr)value;
            }
        }

        public global::System.IntPtr PlaneV
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeV;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeV = (global::System.IntPtr)value;
            }
        }

        public global::System.IntPtr PlaneT
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeT;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->planeT = (global::System.IntPtr)value;
            }
        }

        public int[] Stride
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxImage.__Internal*) __Instance)->stride != null)
                {
                    __value = new int[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = ((global::vpxmd.VpxImage.__Internal*) __Instance)->stride[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((global::vpxmd.VpxImage.__Internal*)__Instance)->stride[i] = value[i];
                }
            }
        }

        public int Bps
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->bps;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->bps = value;
            }
        }

        public global::System.IntPtr UserPriv
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->user_priv;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->user_priv = (global::System.IntPtr) value;
            }
        }

        public byte* ImgData
        {
            get
            {
                return (byte*) ((global::vpxmd.VpxImage.__Internal*) __Instance)->img_data;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->img_data = (global::System.IntPtr) value;
            }
        }

        public int ImgDataOwner
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->img_data_owner;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->img_data_owner = value;
            }
        }

        public int SelfAllocd
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->self_allocd;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->self_allocd = value;
            }
        }

        public global::System.IntPtr FbPriv
        {
            get
            {
                return ((global::vpxmd.VpxImage.__Internal*) __Instance)->fb_priv;
            }

            set
            {
                ((global::vpxmd.VpxImage.__Internal*)__Instance)->fb_priv = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>Representation of a rectangle on a surface</summary>
    public unsafe partial class VpxImageRect : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint x;

            [FieldOffset(4)]
            internal uint y;

            [FieldOffset(8)]
            internal uint w;

            [FieldOffset(12)]
            internal uint h;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_image_rect@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxImageRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxImageRect>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxImageRect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxImageRect(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxImageRect __CreateInstance(global::vpxmd.VpxImageRect.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxImageRect(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxImageRect.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxImageRect.__Internal));
            *(global::vpxmd.VpxImageRect.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxImageRect(global::vpxmd.VpxImageRect.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxImageRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxImageRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxImageRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxImageRect(global::vpxmd.VpxImageRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxImageRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxImageRect.__Internal*) __Instance) = *((global::vpxmd.VpxImageRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxImageRect __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint X
        {
            get
            {
                return ((global::vpxmd.VpxImageRect.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::vpxmd.VpxImageRect.__Internal*)__Instance)->x = value;
            }
        }

        public uint Y
        {
            get
            {
                return ((global::vpxmd.VpxImageRect.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::vpxmd.VpxImageRect.__Internal*)__Instance)->y = value;
            }
        }

        public uint W
        {
            get
            {
                return ((global::vpxmd.VpxImageRect.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::vpxmd.VpxImageRect.__Internal*)__Instance)->w = value;
            }
        }

        public uint H
        {
            get
            {
                return ((global::vpxmd.VpxImageRect.__Internal*) __Instance)->h;
            }

            set
            {
                ((global::vpxmd.VpxImageRect.__Internal*)__Instance)->h = value;
            }
        }
    }

    /// <summary>Stream properties</summary>
    /// <remarks>
    /// <para>This structure is used to query or set properties of the decoded</para>
    /// <para>stream. Algorithms may extend this structure with data specific</para>
    /// <para>to their bitstream by setting the sz member appropriately.</para>
    /// </remarks>
    /// <summary>Initialization Configurations</summary>
    /// <remarks>
    /// <para>This structure is used to pass init time configuration options to the</para>
    /// <para>decoder.</para>
    /// </remarks>
    /// <summary>put frame callback prototype</summary>
    /// <remarks>
    /// <para>This callback is invoked by the decoder to notify the application of</para>
    /// <para>the availability of decoded image data.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void VpxCodecPutFrameCbFnT(global::System.IntPtr user_priv, global::System.IntPtr img);

    /// <summary>put slice callback prototype</summary>
    /// <remarks>
    /// <para>This callback is invoked by the decoder to notify the application of</para>
    /// <para>the availability of partially decoded image data.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void VpxCodecPutSliceCbFnT(global::System.IntPtr user_priv, global::System.IntPtr img, global::System.IntPtr valid, global::System.IntPtr update);

    /// <summary>Stream properties</summary>
    /// <remarks>
    /// <para>This structure is used to query or set properties of the decoded</para>
    /// <para>stream. Algorithms may extend this structure with data specific</para>
    /// <para>to their bitstream by setting the sz member appropriately.</para>
    /// </remarks>
    public unsafe partial class VpxCodecStreamInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint sz;

            [FieldOffset(4)]
            internal uint w;

            [FieldOffset(8)]
            internal uint h;

            [FieldOffset(12)]
            internal uint is_kf;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_codec_stream_info@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecStreamInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecStreamInfo>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecStreamInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecStreamInfo(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecStreamInfo __CreateInstance(global::vpxmd.VpxCodecStreamInfo.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecStreamInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecStreamInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecStreamInfo.__Internal));
            *(global::vpxmd.VpxCodecStreamInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecStreamInfo(global::vpxmd.VpxCodecStreamInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecStreamInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxCodecStreamInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecStreamInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxCodecStreamInfo(global::vpxmd.VpxCodecStreamInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecStreamInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxCodecStreamInfo.__Internal*) __Instance) = *((global::vpxmd.VpxCodecStreamInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxCodecStreamInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Sz
        {
            get
            {
                return ((global::vpxmd.VpxCodecStreamInfo.__Internal*) __Instance)->sz;
            }

            set
            {
                ((global::vpxmd.VpxCodecStreamInfo.__Internal*)__Instance)->sz = value;
            }
        }

        public uint W
        {
            get
            {
                return ((global::vpxmd.VpxCodecStreamInfo.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::vpxmd.VpxCodecStreamInfo.__Internal*)__Instance)->w = value;
            }
        }

        public uint H
        {
            get
            {
                return ((global::vpxmd.VpxCodecStreamInfo.__Internal*) __Instance)->h;
            }

            set
            {
                ((global::vpxmd.VpxCodecStreamInfo.__Internal*)__Instance)->h = value;
            }
        }

        public uint IsKf
        {
            get
            {
                return ((global::vpxmd.VpxCodecStreamInfo.__Internal*) __Instance)->is_kf;
            }

            set
            {
                ((global::vpxmd.VpxCodecStreamInfo.__Internal*)__Instance)->is_kf = value;
            }
        }
    }

    /// <summary>Initialization Configurations</summary>
    /// <remarks>
    /// <para>This structure is used to pass init time configuration options to the</para>
    /// <para>decoder.</para>
    /// </remarks>
    public unsafe partial class VpxCodecDecCfg : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint threads;

            [FieldOffset(4)]
            internal uint w;

            [FieldOffset(8)]
            internal uint h;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_codec_dec_cfg@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecDecCfg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecDecCfg>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecDecCfg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecDecCfg(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecDecCfg __CreateInstance(global::vpxmd.VpxCodecDecCfg.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecDecCfg(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecDecCfg.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecDecCfg.__Internal));
            *(global::vpxmd.VpxCodecDecCfg.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecDecCfg(global::vpxmd.VpxCodecDecCfg.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecDecCfg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxCodecDecCfg()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecDecCfg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxCodecDecCfg(global::vpxmd.VpxCodecDecCfg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecDecCfg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxCodecDecCfg.__Internal*) __Instance) = *((global::vpxmd.VpxCodecDecCfg.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxCodecDecCfg __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Threads
        {
            get
            {
                return ((global::vpxmd.VpxCodecDecCfg.__Internal*) __Instance)->threads;
            }

            set
            {
                ((global::vpxmd.VpxCodecDecCfg.__Internal*)__Instance)->threads = value;
            }
        }

        public uint W
        {
            get
            {
                return ((global::vpxmd.VpxCodecDecCfg.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::vpxmd.VpxCodecDecCfg.__Internal*)__Instance)->w = value;
            }
        }

        public uint H
        {
            get
            {
                return ((global::vpxmd.VpxCodecDecCfg.__Internal*) __Instance)->h;
            }

            set
            {
                ((global::vpxmd.VpxCodecDecCfg.__Internal*)__Instance)->h = value;
            }
        }
    }

    public unsafe partial class vpx_decoder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_dec_init_ver")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecDecInitVer(global::System.IntPtr ctx, global::System.IntPtr iface, global::System.IntPtr cfg, int flags, int ver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_peek_stream_info")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecPeekStreamInfo(global::System.IntPtr iface, byte* data, uint data_sz, global::System.IntPtr si);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_get_stream_info")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecGetStreamInfo(global::System.IntPtr ctx, global::System.IntPtr si);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_decode")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecDecode(global::System.IntPtr ctx, byte* data, uint data_sz, global::System.IntPtr user_priv, int deadline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_get_frame")]
            internal static extern global::System.IntPtr VpxCodecGetFrame(global::System.IntPtr ctx, void** iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_register_put_frame_cb")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecRegisterPutFrameCb(global::System.IntPtr ctx, global::System.IntPtr cb, global::System.IntPtr user_priv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_register_put_slice_cb")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecRegisterPutSliceCb(global::System.IntPtr ctx, global::System.IntPtr cb, global::System.IntPtr user_priv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_set_frame_buffer_functions")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecSetFrameBufferFunctions(global::System.IntPtr ctx, global::System.IntPtr cb_get, global::System.IntPtr cb_release, global::System.IntPtr cb_priv);
        }

        /// <summary>Initialize a decoder instance</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration to use, if known. May be NULL.</param>
        /// <param name="flags">Bitfield of VPX_CODEC_USE_* flags</param>
        /// <param name="ver">
        /// <para>ABI version number. Must be set to</para>
        /// <para>VPX_DECODER_ABI_VERSION</para>
        /// </param>
        /// <remarks>
        /// <para>Initializes a decoder context using the given interface. Applications</para>
        /// <para>should call the vpx_codec_dec_init convenience macro instead of this</para>
        /// <para>function directly, to ensure that the ABI version number parameter</para>
        /// <para>is properly initialized.</para>
        /// <para>If the library was configured with --disable-multithread, this call</para>
        /// <para>is not thread safe and should be guarded with a lock if being used</para>
        /// <para>in a multithreaded context.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>The decoder algorithm initialized.</para>
        /// <para>#VPX_CODEC_MEM_ERROR</para>
        /// <para>Memory allocation failed.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecDecInitVer(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxCodecIface iface, global::vpxmd.VpxCodecDecCfg cfg, int flags, int ver)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __arg2 = ReferenceEquals(cfg, null) ? global::System.IntPtr.Zero : cfg.__Instance;
            var __ret = __Internal.VpxCodecDecInitVer(__arg0, __arg1, __arg2, flags, ver);
            return __ret;
        }

        /// <summary>Parse stream info from a buffer</summary>
        /// <param name="iface">Pointer to the algorithm interface</param>
        /// <param name="data">Pointer to a block of data to parse</param>
        /// <param name="data_sz">Size of the data buffer</param>
        /// <param name="si">
        /// <para>Pointer to stream info to update. The size member</para>
        /// <para>clobbered by the algorithm. This parameter</para>
        /// <para>be NULL.</para>
        /// </param>
        /// <remarks>
        /// <para>Performs high level parsing of the bitstream. Construction of a decoder</para>
        /// <para>context is not necessary. Can be used to determine if the bitstream is</para>
        /// <para>of the proper format, and to extract information from the stream.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>Bitstream is parsable and stream information updated</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecPeekStreamInfo(global::vpxmd.VpxCodecIface iface, byte* data, uint data_sz, global::vpxmd.VpxCodecStreamInfo si)
        {
            var __arg0 = ReferenceEquals(iface, null) ? global::System.IntPtr.Zero : iface.__Instance;
            var __arg3 = ReferenceEquals(si, null) ? global::System.IntPtr.Zero : si.__Instance;
            var __ret = __Internal.VpxCodecPeekStreamInfo(__arg0, data, data_sz, __arg3);
            return __ret;
        }

        /// <summary>Return information about the current stream.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="si">
        /// <para>Pointer to stream info to update. The size member</para>
        /// <para>clobbered by the algorithm. This parameter</para>
        /// <para>be NULL.</para>
        /// </param>
        /// <remarks>
        /// <para>Returns information about the stream that has been parsed during decoding.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>Bitstream is parsable and stream information updated</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecGetStreamInfo(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxCodecStreamInfo si)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(si, null) ? global::System.IntPtr.Zero : si.__Instance;
            var __ret = __Internal.VpxCodecGetStreamInfo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Decode data</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="data">
        /// <para>Pointer to this block of new coded data. If</para>
        /// <para>NULL, the put_frame callback is invoked for</para>
        /// <para>the previously decoded frame.</para>
        /// </param>
        /// <param name="data_sz">Size of the coded data, in bytes.</param>
        /// <param name="user_priv">
        /// <para>Application specific data to associate with</para>
        /// <para>this frame.</para>
        /// </param>
        /// <param name="deadline">
        /// <para>Soft deadline the decoder should attempt to meet,</para>
        /// <para>in us. Set to zero for unlimited.</para>
        /// </param>
        /// <returns>
        /// <para>Returns #VPX_CODEC_OK if the coded data was processed completely</para>
        /// <para>and future pictures can be decoded without error. Otherwise,</para>
        /// <para>see the descriptions of the other error codes in ::vpx_codec_err_t</para>
        /// <para>for recoverability capabilities.</para>
        /// </returns>
        /// <remarks>
        /// <para>Processes a buffer of coded data. If the processing results in a new</para>
        /// <para>decoded frame becoming available, put_slice and put_frame callbacks may be</para>
        /// <para>invoked, as appropriate. Encoded data</para>
        /// <para>time stamp) order. Frames produced will always be in PTS (presentation</para>
        /// <para>time stamp) order.</para>
        /// <para>If the decoder is configured with VPX_CODEC_USE_INPUT_FRAGMENTS enabled,</para>
        /// <para>data and data_sz can contain a fragment of the encoded frame. Fragment</para>
        /// <para>#n must contain at least partition#n, but can also contain subsequent</para>
        /// <para>partitions (#n+1 -#n+i), and if so, fragments#n+1, ..,#n+i must</para>
        /// <para>be empty. When no more data is available, this function should be called</para>
        /// <para>with NULL as data and 0 as data_sz. The memory passed to this function</para>
        /// <para>must be available until the frame has been decoded.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecDecode(global::vpxmd.VpxCodecCtx ctx, byte* data, uint data_sz, global::System.IntPtr user_priv, int deadline)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecDecode(__arg0, data, data_sz, user_priv, deadline);
            return __ret;
        }

        /// <summary>Decoded frames iterator</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="iter">Iterator storage, initialized to NULL</param>
        /// <returns>
        /// <para>Returns a pointer to an image, if one is ready for display. Frames</para>
        /// <para>produced will always be in PTS (presentation time stamp) order.</para>
        /// </returns>
        /// <remarks>
        /// <para>Iterates over a list of the frames available for display. The iterator</para>
        /// <para>storage should be initialized to NULL to start the iteration. Iteration is</para>
        /// <para>complete when this function returns NULL.</para>
        /// <para>The list of available frames becomes valid upon completion of the</para>
        /// <para>vpx_codec_decode call, and remains valid until the next call to</para>
        /// <para>vpx_codec_decode.</para>
        /// </remarks>
        public static global::vpxmd.VpxImage VpxCodecGetFrame(global::vpxmd.VpxCodecCtx ctx, void** iter)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.VpxCodecGetFrame(__arg0, iter);
            global::vpxmd.VpxImage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxImage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxImage) global::vpxmd.VpxImage.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxImage.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Register for notification of frame completion.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cb">Pointer to the callback function</param>
        /// <param name="user_priv">User's private data</param>
        /// <remarks>
        /// <para>Registers a given function to be called when a decoded frame is</para>
        /// <para>available.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>Callback successfully registered.</para>
        /// <para>#VPX_CODEC_ERROR</para>
        /// <para>Decoder context not initialized.</para>
        /// <para>#VPX_CODEC_INCAPABLE</para>
        /// <para>Algorithm not capable of posting frame completion.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecRegisterPutFrameCb(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxCodecPutFrameCbFnT cb, global::System.IntPtr user_priv)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var __ret = __Internal.VpxCodecRegisterPutFrameCb(__arg0, __arg1, user_priv);
            return __ret;
        }

        /// <summary>Register for notification of slice completion.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cb">Pointer to the callback function</param>
        /// <param name="user_priv">User's private data</param>
        /// <remarks>
        /// <para>Registers a given function to be called when a decoded slice is</para>
        /// <para>available.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>Callback successfully registered.</para>
        /// <para>#VPX_CODEC_ERROR</para>
        /// <para>Decoder context not initialized.</para>
        /// <para>#VPX_CODEC_INCAPABLE</para>
        /// <para>Algorithm not capable of posting slice completion.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecRegisterPutSliceCb(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxCodecPutSliceCbFnT cb, global::System.IntPtr user_priv)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var __ret = __Internal.VpxCodecRegisterPutSliceCb(__arg0, __arg1, user_priv);
            return __ret;
        }

        /// <summary>Pass in external frame buffers for the decoder to use.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cb_get">Pointer to the get callback function</param>
        /// <param name="cb_release">Pointer to the release callback function</param>
        /// <param name="cb_priv">Callback's private data</param>
        /// <remarks>
        /// <para>Registers functions to be called when libvpx needs a frame buffer</para>
        /// <para>to decode the current frame and a function to be called when libvpx does</para>
        /// <para>not internally reference the frame buffer. This set function must</para>
        /// <para>be called before the first call to decode or libvpx will assume the</para>
        /// <para>default behavior of allocating frame buffers internally.</para>
        /// <para>#VPX_CODEC_OK</para>
        /// <para>External frame buffers will be used by libvpx.</para>
        /// <para>#VPX_CODEC_INVALID_PARAM</para>
        /// <para>One or more of the callbacks were NULL.</para>
        /// <para>#VPX_CODEC_ERROR</para>
        /// <para>Decoder context not initialized.</para>
        /// <para>#VPX_CODEC_INCAPABLE</para>
        /// <para>Algorithm not capable of using external frame buffers.</para>
        /// <para>When decoding VP9, the application may be required to pass in at least</para>
        /// <para>#VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS external frame</para>
        /// <para>buffers.</para>
        /// </remarks>
        public static global::vpxmd.VpxCodecErrT VpxCodecSetFrameBufferFunctions(global::vpxmd.VpxCodecCtx ctx, global::vpxmd.VpxGetFrameBufferCbFnT cb_get, global::vpxmd.VpxReleaseFrameBufferCbFnT cb_release, global::System.IntPtr cb_priv)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = cb_get == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb_get);
            var __arg2 = cb_release == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb_release);
            var __ret = __Internal.VpxCodecSetFrameBufferFunctions(__arg0, __arg1, __arg2, cb_priv);
            return __ret;
        }
    }

    /// <summary>External frame buffer</summary>
    /// <remarks>This structure holds allocated frame buffers used by the decoder.</remarks>
    /// <summary>get frame buffer callback prototype</summary>
    /// <param name="priv">Callback's private data</param>
    /// <param name="min_size">Size in bytes needed by the buffer</param>
    /// <param name="fb">Pointer to vpx_codec_frame_buffer_t</param>
    /// <remarks>
    /// <para>This callback is invoked by the decoder to retrieve data for the frame</para>
    /// <para>buffer in order for the decode call to complete. The callback must</para>
    /// <para>allocate at least min_size in bytes and assign it to fb-&gt;data. The callback</para>
    /// <para>must zero out all the data allocated. Then the callback must set fb-&gt;size</para>
    /// <para>to the allocated size. The application does not need to align the allocated</para>
    /// <para>data. The callback is triggered when the decoder needs a frame buffer to</para>
    /// <para>decode a compressed image into. This function may be called more than once</para>
    /// <para>for every call to vpx_codec_decode. The application may set fb-&gt;priv to</para>
    /// <para>some data which will be passed back in the vpx_image_t and the release</para>
    /// <para>function call. |fb| is guaranteed to not be NULL. On success the callback</para>
    /// <para>must return 0. Any failure the callback must return a value less than 0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int VpxGetFrameBufferCbFnT(global::System.IntPtr priv, ulong min_size, global::System.IntPtr fb);

    /// <summary>release frame buffer callback prototype</summary>
    /// <param name="priv">Callback's private data</param>
    /// <param name="fb">Pointer to vpx_codec_frame_buffer_t</param>
    /// <remarks>
    /// <para>This callback is invoked by the decoder when the frame buffer is not</para>
    /// <para>referenced by any other buffers. |fb| is guaranteed to not be NULL. On</para>
    /// <para>success the callback must return 0. Any failure the callback must return</para>
    /// <para>a value less than 0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int VpxReleaseFrameBufferCbFnT(global::System.IntPtr priv, global::System.IntPtr fb);

    /// <summary>External frame buffer</summary>
    /// <remarks>This structure holds allocated frame buffers used by the decoder.</remarks>
    public unsafe partial class VpxCodecFrameBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr data;

            [FieldOffset(8)]
            internal ulong size;

            [FieldOffset(16)]
            internal global::System.IntPtr priv;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_codec_frame_buffer@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecFrameBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxCodecFrameBuffer>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxCodecFrameBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecFrameBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxCodecFrameBuffer __CreateInstance(global::vpxmd.VpxCodecFrameBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxCodecFrameBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxCodecFrameBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecFrameBuffer.__Internal));
            *(global::vpxmd.VpxCodecFrameBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecFrameBuffer(global::vpxmd.VpxCodecFrameBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxCodecFrameBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxCodecFrameBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecFrameBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxCodecFrameBuffer(global::vpxmd.VpxCodecFrameBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxCodecFrameBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxCodecFrameBuffer.__Internal*) __Instance) = *((global::vpxmd.VpxCodecFrameBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxCodecFrameBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((global::vpxmd.VpxCodecFrameBuffer.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::vpxmd.VpxCodecFrameBuffer.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public ulong Size
        {
            get
            {
                return ((global::vpxmd.VpxCodecFrameBuffer.__Internal*) __Instance)->size;
            }

            set
            {
                ((global::vpxmd.VpxCodecFrameBuffer.__Internal*)__Instance)->size = value;
            }
        }

        public global::System.IntPtr Priv
        {
            get
            {
                return ((global::vpxmd.VpxCodecFrameBuffer.__Internal*) __Instance)->priv;
            }

            set
            {
                ((global::vpxmd.VpxCodecFrameBuffer.__Internal*)__Instance)->priv = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>VPx encoder control functions</summary>
    /// <remarks>
    /// <para>This set of macros define the control functions available for VPx</para>
    /// <para>encoder interface.</para>
    /// <para>#vpx_codec_control</para>
    /// </remarks>
    public enum Vp8eEncControlId
    {
        /// <summary>Codec control function to pass an ROI map to encoder.</summary>
        /// <remarks>Supported in codecs: VP8</remarks>
        VP8E_SET_ROI_MAP = 8,
        /// <summary>Codec control function to pass an Active map to encoder.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_ACTIVEMAP = 9,
        /// <summary>Codec control function to set encoder scaling mode.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_SCALEMODE = 11,
        /// <summary>Codec control function to set encoder internal speed settings.</summary>
        /// <remarks>
        /// <para>Changes in this value influences, among others, the encoder's selection</para>
        /// <para>of motion estimation methods. Values greater than 0 will increase encoder</para>
        /// <para>speed at the expense of quality.</para>
        /// <para>Valid range for VP8: -16..16</para>
        /// <para>Valid range for VP9: -9..9</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_CPUUSED = 13,
        /// <summary>Codec control function to enable automatic use of arf frames.</summary>
        /// <remarks>
        /// <para>Valid range for VP8: 0..1</para>
        /// <para>Valid range for VP9: 0..6</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_ENABLEAUTOALTREF = 14,
        /// <summary>control function to set noise sensitivity</summary>
        /// <remarks>
        /// <para>0: off, 1: OnYOnly, 2: OnYUV,</para>
        /// <para>3: OnYUVAggressive, 4: Adaptive</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_NOISE_SENSITIVITY = 15,
        /// <summary>
        /// <para>Codec control function to set higher sharpness at the expense</para>
        /// <para>of a lower PSNR.</para>
        /// </summary>
        /// <remarks>
        /// <para>Valid range: 0..7</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_SHARPNESS = 16,
        /// <summary>Codec control function to set the threshold for MBs treated static.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_STATIC_THRESHOLD = 17,
        /// <summary>Codec control function to set the number of token partitions.</summary>
        /// <remarks>Supported in codecs: VP8</remarks>
        VP8E_SET_TOKEN_PARTITIONS = 18,
        /// <summary>Codec control function to get last quantizer chosen by the encoder.</summary>
        /// <remarks>
        /// <para>Return value uses internal quantizer scale defined by the codec.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_GET_LAST_QUANTIZER = 19,
        /// <summary>Codec control function to get last quantizer chosen by the encoder.</summary>
        /// <remarks>
        /// <para>Return value uses the 0..63 scale as used by the rc_*_quantizer config</para>
        /// <para>parameters.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_GET_LAST_QUANTIZER_64 = 20,
        /// <summary>Codec control function to set the max no of frames to create arf.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_ARNR_MAXFRAMES = 21,
        /// <summary>Codec control function to set the filter strength for the arf.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_ARNR_STRENGTH = 22,
        /// <remarks>control function to set the filter type to use for the arf.</remarks>
        VP8E_SET_ARNR_TYPE = 23,
        /// <summary>Codec control function to set visual tuning.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_TUNING = 24,
        /// <summary>Codec control function to set constrained / constant quality level.</summary>
        /// <remarks>
        /// <para>For this value to be used vpx_codec_enc_cfg_t::rc_end_usage must</para>
        /// <para>be set to #VPX_CQ or #VPX_Q</para>
        /// <para>Valid range: 0..63</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_CQ_LEVEL = 25,
        /// <summary>Codec control function to set Max data rate for Intra frames.</summary>
        /// <remarks>
        /// <para>This value controls additional clamping on the maximum size of a</para>
        /// <para>keyframe. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>unlimited, or no additional clamping beyond the codec's built-in</para>
        /// <para>algorithm.</para>
        /// <para>For example, to allocate no more than 4.5 frames worth of bitrate</para>
        /// <para>to a keyframe, set this to 450.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_MAX_INTRA_BITRATE_PCT = 26,
        /// <summary>Codec control function to set reference and update frame flags.</summary>
        /// <remarks>Supported in codecs: VP8</remarks>
        VP8E_SET_FRAME_FLAGS = 27,
        /// <summary>Codec control function to set max data rate for Inter frames.</summary>
        /// <remarks>
        /// <para>This value controls additional clamping on the maximum size of an</para>
        /// <para>inter frame. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>unlimited, or no additional clamping beyond the codec's built-in</para>
        /// <para>algorithm.</para>
        /// <para>For example, to allow no more than 4.5 frames worth of bitrate</para>
        /// <para>to an inter frame, set this to 450.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_MAX_INTER_BITRATE_PCT = 28,
        /// <summary>Boost percentage for Golden Frame in CBR mode.</summary>
        /// <remarks>
        /// <para>This value controls the amount of boost given to Golden Frame in</para>
        /// <para>CBR mode. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>the feature is off, i.e., no golden frame boost in CBR mode and</para>
        /// <para>average bitrate target is used.</para>
        /// <para>For example, to allow 100% more bits, i.e, 2X, in a golden frame</para>
        /// <para>than average frame, set this to 100.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_GF_CBR_BOOST_PCT = 29,
        /// <summary>Codec control function to set the temporal layer id.</summary>
        /// <remarks>
        /// <para>For temporal scalability: this control allows the application to set the</para>
        /// <para>layer id for each frame to be encoded. Note that this control must be set</para>
        /// <para>for every frame prior to encoding. The usage of this control function</para>
        /// <para>supersedes the internal temporal pattern counter, which is now deprecated.</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_TEMPORAL_LAYER_ID = 30,
        /// <summary>Codec control function to set encoder screen content mode.</summary>
        /// <remarks>
        /// <para>0: off, 1: On, 2: On with more aggressive rate control.</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_SCREEN_CONTENT_MODE = 31,
        /// <summary>Codec control function to set lossless encoding mode.</summary>
        /// <remarks>
        /// <para>VP9 can operate in lossless encoding mode, in which the bitstream</para>
        /// <para>produced will be able to decode and reconstruct a perfect copy of</para>
        /// <para>input source. This control function provides a mean to switch encoder</para>
        /// <para>into lossless coding mode(1) or normal coding mode(0) that may be lossy.</para>
        /// <para>0 = lossy coding mode</para>
        /// <para>1 = lossless coding mode</para>
        /// <para>By default, encoder operates in normal coding mode (maybe lossy).</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_LOSSLESS = 32,
        /// <summary>Codec control function to set number of tile columns.</summary>
        /// <remarks>
        /// <para>In encoding and decoding, VP9 allows an input image frame be partitioned</para>
        /// <para>into separated vertical tile columns, which can be encoded or decoded</para>
        /// <para>independently. This enables easy implementation of parallel encoding and</para>
        /// <para>decoding. This control requests the encoder to use column tiles in</para>
        /// <para>encoding an input frame, with number of tile columns (in Log2 unit) as</para>
        /// <para>the parameter:</para>
        /// <para>0 = 1 tile column</para>
        /// <para>1 = 2 tile columns</para>
        /// <para>2 = 4 tile columns</para>
        /// <para>.....</para>
        /// <para>n = 2**n tile columns</para>
        /// <para>The requested tile columns will be capped by the encoder based on image</para>
        /// <para>size limitations (The minimum width of a tile column is 256 pixels, the</para>
        /// <para>maximum is 4096).</para>
        /// <para>By default, the value is 6, i.e., the maximum number of tiles supported by</para>
        /// <para>the resolution.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TILE_COLUMNS = 33,
        /// <summary>Codec control function to set number of tile rows.</summary>
        /// <remarks>
        /// <para>In encoding and decoding, VP9 allows an input image frame be partitioned</para>
        /// <para>into separated horizontal tile rows. Tile rows are encoded or decoded</para>
        /// <para>sequentially. Even though encoding/decoding of later tile rows depends on</para>
        /// <para>earlier ones, this allows the encoder to output data packets for tile rows</para>
        /// <para>prior to completely processing all tile rows in a frame, thereby reducing</para>
        /// <para>the latency in processing between input and output. The parameter</para>
        /// <para>for this control describes the number of tile rows, which has a valid</para>
        /// <para>range [0, 2]:</para>
        /// <para>0 = 1 tile row</para>
        /// <para>1 = 2 tile rows</para>
        /// <para>2 = 4 tile rows</para>
        /// <para>By default, the value is 0, i.e. one single row tile for entire image.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TILE_ROWS = 34,
        /// <summary>Codec control function to enable frame parallel decoding feature.</summary>
        /// <remarks>
        /// <para>VP9 has a bitstream feature to reduce decoding dependency between frames</para>
        /// <para>by turning off backward update of probability context used in encoding</para>
        /// <para>and decoding. This allows staged parallel processing of more than one</para>
        /// <para>video frame in the decoder. This control function provides a means to</para>
        /// <para>turn this feature on or off for bitstreams produced by encoder.</para>
        /// <para>By default, this feature is on.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_FRAME_PARALLEL_DECODING = 35,
        /// <summary>Codec control function to set adaptive quantization mode.</summary>
        /// <remarks>
        /// <para>VP9 has a segment based feature that allows encoder to adaptively change</para>
        /// <para>quantization parameter for each segment within a frame to improve the</para>
        /// <para>subjective quality. This control makes encoder operate in one of the</para>
        /// <para>several AQ_modes supported.</para>
        /// <para>By default, encoder operates with AQ_Mode 0(adaptive quantization off).</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_AQ_MODE = 36,
        /// <summary>Codec control function to enable/disable periodic Q boost.</summary>
        /// <remarks>
        /// <para>One VP9 encoder speed feature is to enable quality boost by lowering</para>
        /// <para>frame level Q periodically. This control function provides a mean to</para>
        /// <para>turn on/off this feature.</para>
        /// <para>0 = off</para>
        /// <para>1 = on</para>
        /// <para>By default, the encoder is allowed to use this feature for appropriate</para>
        /// <para>encoding modes.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_FRAME_PERIODIC_BOOST = 37,
        /// <summary>Codec control function to set noise sensitivity.</summary>
        /// <remarks>
        /// <para>0: off, 1: On(YOnly), 2: For SVC only, on top two spatial layers(YOnly)</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_NOISE_SENSITIVITY = 38,
        /// <summary>Codec control function to turn on/off SVC in encoder.</summary>
        /// <remarks>
        /// <para>Return value is VPX_CODEC_INVALID_PARAM if the encoder does not</para>
        /// <para>support SVC in its current encoding mode</para>
        /// <para>0: off, 1: on</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC = 39,
        /// <summary>Codec control function to pass an ROI map to encoder.</summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_SET_ROI_MAP = 40,
        /// <summary>Codec control function to set parameters for SVC.</summary>
        /// <remarks>
        /// <para>Parameters contain min_q, max_q, scaling factor for each of the</para>
        /// <para>SVC layers.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_PARAMETERS = 41,
        /// <summary>Codec control function to set svc layer for spatial and temporal.</summary>
        /// <remarks>
        /// <para>Valid ranges: 0..#vpx_codec_enc_cfg::ss_number_layers for spatial</para>
        /// <para>layer and 0..#vpx_codec_enc_cfg::ts_number_layers for</para>
        /// <para>temporal layer.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_LAYER_ID = 42,
        /// <summary>Codec control function to set content type.</summary>
        /// <remarks>
        /// <para>Valid parameter range:</para>
        /// <para>VP9E_CONTENT_DEFAULT = Regular video content (Default)</para>
        /// <para>VP9E_CONTENT_SCREEN  = Screen capture content</para>
        /// <para>VP9E_CONTENT_FILM    = Film content: improves grain retention</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TUNE_CONTENT = 43,
        /// <summary>Codec control function to get svc layer ID.</summary>
        /// <remarks>
        /// <para>The layer ID returned is for the data packet from the registered</para>
        /// <para>callback function.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_GET_SVC_LAYER_ID = 44,
        /// <summary>Codec control function to register callback to get per layer packet.</summary>
        /// <remarks>
        /// <para>Parameter for this control function is a structure with a callback</para>
        /// <para>function and a pointer to private data used by the callback.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_REGISTER_CX_CALLBACK = 45,
        /// <summary>Codec control function to set color space info.</summary>
        /// <remarks>
        /// <para>Valid ranges: 0..7, default is &quot;UNKNOWN&quot;.</para>
        /// <para>0 = UNKNOWN,</para>
        /// <para>1 = BT_601</para>
        /// <para>2 = BT_709</para>
        /// <para>3 = SMPTE_170</para>
        /// <para>4 = SMPTE_240</para>
        /// <para>5 = BT_2020</para>
        /// <para>6 = RESERVED</para>
        /// <para>7 = SRGB</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_COLOR_SPACE = 46,
        /// <summary>Codec control function to set temporal layering mode.</summary>
        /// <remarks>
        /// <para>Valid ranges: 0..3, default is &quot;0&quot;</para>
        /// <para>(VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING).</para>
        /// <para>0 = VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING</para>
        /// <para>1 = VP9E_TEMPORAL_LAYERING_MODE_BYPASS</para>
        /// <para>2 = VP9E_TEMPORAL_LAYERING_MODE_0101</para>
        /// <para>3 = VP9E_TEMPORAL_LAYERING_MODE_0212</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TEMPORAL_LAYERING_MODE = 47,
        /// <summary>Codec control function to set minimum interval between GF/ARF frames</summary>
        /// <remarks>
        /// <para>By default the value is set as 4.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_MIN_GF_INTERVAL = 48,
        /// <summary>Codec control function to set minimum interval between GF/ARF frames</summary>
        /// <remarks>
        /// <para>By default the value is set as 16.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_MAX_GF_INTERVAL = 49,
        /// <summary>Codec control function to get an Active map back from the encoder.</summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_GET_ACTIVEMAP = 50,
        /// <summary>Codec control function to set color range bit.</summary>
        /// <remarks>
        /// <para>Valid ranges: 0..1, default is 0</para>
        /// <para>0 = Limited range (16..235 or HBD equivalent)</para>
        /// <para>1 = Full range (0..255 or HBD equivalent)</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_COLOR_RANGE = 51,
        /// <summary>
        /// <para>Codec control function to set the frame flags and buffer indices</para>
        /// <para>for spatial layers. The frame flags and buffer indices are set using the</para>
        /// <para>struct #vpx_svc_ref_frame_config defined below.</para>
        /// </summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_SET_SVC_REF_FRAME_CONFIG = 52,
        /// <summary>Codec control function to set intended rendering image size.</summary>
        /// <remarks>
        /// <para>By default, this is identical to the image size in pixels.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_RENDER_SIZE = 53,
        /// <summary>Codec control function to set target level.</summary>
        /// <remarks>
        /// <para>255: off (default); 0: only keep level stats; 10: target for level 1.0;</para>
        /// <para>11: target for level 1.1; ... 62: target for level 6.2</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TARGET_LEVEL = 54,
        /// <summary>Codec control function to set row level multi-threading.</summary>
        /// <remarks>
        /// <para>0 : off, 1 : on</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_ROW_MT = 55,
        /// <summary>Codec control function to get bitstream level.</summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_GET_LEVEL = 56,
        /// <summary>
        /// <para>Codec control function to enable/disable special mode for altref</para>
        /// <para>adaptive quantization. You can use it with --aq-mode concurrently.</para>
        /// </summary>
        /// <remarks>
        /// <para>Enable special adaptive quantization for altref frames based on their</para>
        /// <para>expected prediction quality for the future frames.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_ALT_REF_AQ = 57,
        /// <summary>Boost percentage for Golden Frame in CBR mode.</summary>
        /// <remarks>
        /// <para>This value controls the amount of boost given to Golden Frame in</para>
        /// <para>CBR mode. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>the feature is off, i.e., no golden frame boost in CBR mode and</para>
        /// <para>average bitrate target is used.</para>
        /// <para>For example, to allow 100% more bits, i.e, 2X, in a golden frame</para>
        /// <para>than average frame, set this to 100.</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_GF_CBR_BOOST_PCT = 58,
        /// <summary>
        /// <para>Codec control function to enable the extreme motion vector unit test</para>
        /// <para>in VP9. Please note that this is only used in motion vector unit test.</para>
        /// </summary>
        /// <remarks>
        /// <para>0 : off, 1 : MAX_EXTREME_MV, 2 : MIN_EXTREME_MV</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST = 59,
        /// <summary>
        /// <para>Codec control function to constrain the inter-layer prediction</para>
        /// <para>(prediction of lower spatial resolution) in VP9 SVC.</para>
        /// </summary>
        /// <remarks>
        /// <para>0 : inter-layer prediction on, 1 : off, 2 : off only on non-key frames</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_INTER_LAYER_PRED = 60,
        /// <summary>
        /// <para>Codec control function to set mode and thresholds for frame</para>
        /// <para>dropping in SVC. Drop frame thresholds are set per-layer. Mode is set as:</para>
        /// <para>0 : layer-dependent dropping, 1 : constrained dropping, current layer drop</para>
        /// <para>forces drop on all upper layers. Default mode is 0.</para>
        /// </summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_SET_SVC_FRAME_DROP_LAYER = 61,
        /// <summary>
        /// <para>Codec control function to get the refresh and reference flags and</para>
        /// <para>the buffer indices, up to the last encoded spatial layer.</para>
        /// </summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_GET_SVC_REF_FRAME_CONFIG = 62,
        /// <summary>
        /// <para>Codec control function to enable/disable use of golden reference as</para>
        /// <para>a second temporal reference for SVC. Only used when inter-layer prediction</para>
        /// <para>is disabled on INTER frames.</para>
        /// </summary>
        /// <remarks>
        /// <para>0: Off, 1: Enabled (default)</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_GF_TEMPORAL_REF = 63,
        /// <summary>
        /// <para>Codec control function to enable spatial layer sync frame, for any</para>
        /// <para>spatial layer. Enabling it for layer k means spatial layer k will disable</para>
        /// <para>all temporal prediction, but keep the inter-layer prediction. It will</para>
        /// <para>refresh any temporal reference buffer for that layer, and reset the</para>
        /// <para>temporal layer for the superframe to 0. Setting the layer sync for base</para>
        /// <para>spatial layer forces a key frame. Default is off (0) for all spatial</para>
        /// <para>layers. Spatial layer sync flag is reset to 0 after each encoded layer,</para>
        /// <para>so when control is invoked it is only used for the current superframe.</para>
        /// </summary>
        /// <remarks>
        /// <para>0: Off (default), 1: Enabled</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_SPATIAL_LAYER_SYNC = 64,
        /// <summary>Codec control function to enable temporal dependency model.</summary>
        /// <remarks>
        /// <para>Vp9 allows the encoder to run temporal dependency model and use it to</para>
        /// <para>improve the compression performance. To enable, set this parameter to be</para>
        /// <para>1. The default value is set to be 1.</para>
        /// </remarks>
        VP9E_SET_TPL = 65,
        /// <summary>Codec control function to enable postencode frame drop.</summary>
        /// <remarks>
        /// <para>This will allow encoder to drop frame after it's encoded.</para>
        /// <para>0: Off (default), 1: Enabled</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_POSTENCODE_DROP = 66,
        /// <summary>Codec control function to set delta q for uv.</summary>
        /// <remarks>
        /// <para>Cap it at +/-15.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_DELTA_Q_UV = 67
    }

    /// <summary>vpx 1-D scaling mode</summary>
    /// <remarks>This set of constants define 1-D vpx scaling modes</remarks>
    public enum VpxScalingMode1d
    {
        VP8E_NORMAL = 0,
        VP8E_FOURFIVE = 1,
        VP8E_THREEFIVE = 2,
        VP8E_ONETWO = 3
    }

    /// <summary>Temporal layering mode enum for VP9 SVC.</summary>
    /// <remarks>
    /// <para>This set of macros define the different temporal layering modes.</para>
    /// <para>Supported codecs: VP9 (in SVC mode)</para>
    /// </remarks>
    public enum Vp9eTemporalLayeringMode
    {
        /// <summary>
        /// <para>No temporal layering.</para>
        /// <para>Used when only spatial layering is used.</para>
        /// </summary>
        VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING = 0,
        /// <summary>
        /// <para>Bypass mode.</para>
        /// <para>Used when application needs to control temporal layering.</para>
        /// <para>This will only work when the number of spatial layers equals 1.</para>
        /// </summary>
        VP9E_TEMPORAL_LAYERING_MODE_BYPASS = 1,
        /// <summary>0-1-0-1... temporal layering scheme with two temporal layers.</summary>
        VP9E_TEMPORAL_LAYERING_MODE_0101 = 2,
        /// <summary>0-2-1-2... temporal layering scheme with three temporal layers.</summary>
        VP9E_TEMPORAL_LAYERING_MODE_0212 = 3
    }

    /// <summary>VP8 token partition mode</summary>
    /// <remarks>
    /// <para>This defines VP8 partitioning mode for compressed data, i.e., the number of</para>
    /// <para>sub-streams in the bitstream. Used for parallelized decoding.</para>
    /// </remarks>
    public enum Vp8eTokenPartitions
    {
        VP8ONE_TOKENPARTITION = 0,
        VP8TWO_TOKENPARTITION = 1,
        VP8FOUR_TOKENPARTITION = 2,
        VP8EIGHT_TOKENPARTITION = 3
    }

    /// <summary>brief VP9 encoder content type</summary>
    public enum Vp9eTuneContent
    {
        VP9E_CONTENT_DEFAULT = 0,
        VP9E_CONTENT_SCREEN = 1,
        VP9E_CONTENT_FILM = 2,
        VP9E_CONTENT_INVALID = 3
    }

    /// <summary>VP8 model tuning parameters</summary>
    /// <remarks>Changes the encoder to tune for certain types of input material.</remarks>
    public enum Vp8eTuning
    {
        VP8TUNE_PSNR = 0,
        VP8TUNE_SSIM = 1
    }

    /// <summary>VP9 svc frame dropping mode.</summary>
    /// <remarks>This defines the frame drop mode for SVC.</remarks>
    public enum SVC_LAYER_DROP_MODE
    {
        CONSTRAINED_LAYER_DROP = 0,
        /// <summary>Any spatial layer can drop.</summary>
        LAYER_DROP = 1,
        /// <summary>Only full superframe can drop.</summary>
        FULL_SUPERFRAME_DROP = 2,
        CONSTRAINED_FROM_ABOVE_DROP = 3
    }

    /// <summary>vpx 1-D scaling mode</summary>
    /// <remarks>This set of constants define 1-D vpx scaling modes</remarks>
    /// <summary>Temporal layering mode enum for VP9 SVC.</summary>
    /// <remarks>
    /// <para>This set of macros define the different temporal layering modes.</para>
    /// <para>Supported codecs: VP9 (in SVC mode)</para>
    /// </remarks>
    /// <summary>vpx region of interest map</summary>
    /// <remarks>These defines the data structures for the region of interest map</remarks>
    /// <summary>vpx active region map</summary>
    /// <remarks>These defines the data structures for active region map</remarks>
    /// <summary>vpx image scaling mode</summary>
    /// <remarks>This defines the data structure for image scaling mode</remarks>
    /// <summary>VP8 token partition mode</summary>
    /// <remarks>
    /// <para>This defines VP8 partitioning mode for compressed data, i.e., the number of</para>
    /// <para>sub-streams in the bitstream. Used for parallelized decoding.</para>
    /// </remarks>
    /// <summary>brief VP9 encoder content type</summary>
    /// <summary>VP8 model tuning parameters</summary>
    /// <remarks>Changes the encoder to tune for certain types of input material.</remarks>
    /// <summary>vp9 svc layer parameters</summary>
    /// <remarks>
    /// <para>This defines the spatial and temporal layer id numbers for svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_LAYER_ID control to set the spatial and</para>
    /// <para>temporal layer id for the current frame.</para>
    /// </remarks>
    /// <summary>vp9 svc frame flag parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame flags and buffer indices for each spatial layer for</para>
    /// <para>svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_REF_FRAME_CONFIG control to set frame</para>
    /// <para>flags and buffer indices for each spatial layer for the current (super)frame.</para>
    /// </remarks>
    /// <summary>VP9 svc frame dropping mode.</summary>
    /// <remarks>This defines the frame drop mode for SVC.</remarks>
    /// <summary>vp9 svc frame dropping parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame drop thresholds for each spatial layer, and</para>
    /// <para>the frame dropping mode: 0 = layer based frame dropping (default),</para>
    /// <para>1 = constrained dropping where current layer drop forces all upper</para>
    /// <para>spatial layers to drop.</para>
    /// </remarks>
    /// <summary>vp9 svc spatial layer sync parameters.</summary>
    /// <remarks>This defines the spatial layer sync flag, defined per spatial layer.</remarks>
    /// <summary>vpx region of interest map</summary>
    /// <remarks>These defines the data structures for the region of interest map</remarks>
    public unsafe partial class VpxRoiMap : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 168)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte enabled;

            [FieldOffset(8)]
            internal global::System.IntPtr roi_map;

            [FieldOffset(16)]
            internal uint rows;

            [FieldOffset(20)]
            internal uint cols;

            [FieldOffset(24)]
            internal fixed int delta_q[8];

            [FieldOffset(56)]
            internal fixed int delta_lf[8];

            [FieldOffset(88)]
            internal fixed int skip[8];

            [FieldOffset(120)]
            internal fixed int ref_frame[8];

            [FieldOffset(152)]
            internal fixed uint static_threshold[4];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_roi_map@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxRoiMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxRoiMap>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxRoiMap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxRoiMap(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxRoiMap __CreateInstance(global::vpxmd.VpxRoiMap.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxRoiMap(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxRoiMap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRoiMap.__Internal));
            *(global::vpxmd.VpxRoiMap.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRoiMap(global::vpxmd.VpxRoiMap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxRoiMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxRoiMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRoiMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxRoiMap(global::vpxmd.VpxRoiMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRoiMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxRoiMap.__Internal*) __Instance) = *((global::vpxmd.VpxRoiMap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxRoiMap __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Enabled
        {
            get
            {
                return ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->enabled;
            }

            set
            {
                ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->enabled = value;
            }
        }

        public byte* RoiMap
        {
            get
            {
                return (byte*) ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->roi_map;
            }

            set
            {
                ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->roi_map = (global::System.IntPtr) value;
            }
        }

        public uint Rows
        {
            get
            {
                return ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->rows;
            }

            set
            {
                ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->rows = value;
            }
        }

        public uint Cols
        {
            get
            {
                return ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->cols;
            }

            set
            {
                ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->cols = value;
            }
        }

        public int[] DeltaQ
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->delta_q != null)
                {
                    __value = new int[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->delta_q[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->delta_q[i] = value[i];
                }
            }
        }

        public int[] DeltaLf
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->delta_lf != null)
                {
                    __value = new int[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->delta_lf[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->delta_lf[i] = value[i];
                }
            }
        }

        public int[] Skip
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->skip != null)
                {
                    __value = new int[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->skip[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->skip[i] = value[i];
                }
            }
        }

        public int[] RefFrame
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->ref_frame != null)
                {
                    __value = new int[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->ref_frame[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->ref_frame[i] = value[i];
                }
            }
        }

        public uint[] StaticThreshold
        {
            get
            {
                uint[] __value = null;
                if (((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->static_threshold != null)
                {
                    __value = new uint[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = ((global::vpxmd.VpxRoiMap.__Internal*) __Instance)->static_threshold[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((global::vpxmd.VpxRoiMap.__Internal*)__Instance)->static_threshold[i] = value[i];
                }
            }
        }
    }

    /// <summary>vpx active region map</summary>
    /// <remarks>These defines the data structures for active region map</remarks>
    public unsafe partial class VpxActiveMap : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr active_map;

            [FieldOffset(8)]
            internal uint rows;

            [FieldOffset(12)]
            internal uint cols;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_active_map@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxActiveMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxActiveMap>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxActiveMap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxActiveMap(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxActiveMap __CreateInstance(global::vpxmd.VpxActiveMap.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxActiveMap(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxActiveMap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxActiveMap.__Internal));
            *(global::vpxmd.VpxActiveMap.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxActiveMap(global::vpxmd.VpxActiveMap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxActiveMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxActiveMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxActiveMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxActiveMap(global::vpxmd.VpxActiveMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxActiveMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxActiveMap.__Internal*) __Instance) = *((global::vpxmd.VpxActiveMap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxActiveMap __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* ActiveMap
        {
            get
            {
                return (byte*) ((global::vpxmd.VpxActiveMap.__Internal*) __Instance)->active_map;
            }

            set
            {
                ((global::vpxmd.VpxActiveMap.__Internal*)__Instance)->active_map = (global::System.IntPtr) value;
            }
        }

        public uint Rows
        {
            get
            {
                return ((global::vpxmd.VpxActiveMap.__Internal*) __Instance)->rows;
            }

            set
            {
                ((global::vpxmd.VpxActiveMap.__Internal*)__Instance)->rows = value;
            }
        }

        public uint Cols
        {
            get
            {
                return ((global::vpxmd.VpxActiveMap.__Internal*) __Instance)->cols;
            }

            set
            {
                ((global::vpxmd.VpxActiveMap.__Internal*)__Instance)->cols = value;
            }
        }
    }

    /// <summary>vpx image scaling mode</summary>
    /// <remarks>This defines the data structure for image scaling mode</remarks>
    public unsafe partial class VpxScalingMode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::vpxmd.VpxScalingMode1d h_scaling_mode;

            [FieldOffset(4)]
            internal global::vpxmd.VpxScalingMode1d v_scaling_mode;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_scaling_mode@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxScalingMode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxScalingMode>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxScalingMode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxScalingMode(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxScalingMode __CreateInstance(global::vpxmd.VpxScalingMode.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxScalingMode(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxScalingMode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxScalingMode.__Internal));
            *(global::vpxmd.VpxScalingMode.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxScalingMode(global::vpxmd.VpxScalingMode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxScalingMode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxScalingMode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxScalingMode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxScalingMode(global::vpxmd.VpxScalingMode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxScalingMode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxScalingMode.__Internal*) __Instance) = *((global::vpxmd.VpxScalingMode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxScalingMode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::vpxmd.VpxScalingMode1d HScalingMode
        {
            get
            {
                return ((global::vpxmd.VpxScalingMode.__Internal*) __Instance)->h_scaling_mode;
            }

            set
            {
                ((global::vpxmd.VpxScalingMode.__Internal*)__Instance)->h_scaling_mode = value;
            }
        }

        public global::vpxmd.VpxScalingMode1d VScalingMode
        {
            get
            {
                return ((global::vpxmd.VpxScalingMode.__Internal*) __Instance)->v_scaling_mode;
            }

            set
            {
                ((global::vpxmd.VpxScalingMode.__Internal*)__Instance)->v_scaling_mode = value;
            }
        }
    }

    /// <summary>vp9 svc layer parameters</summary>
    /// <remarks>
    /// <para>This defines the spatial and temporal layer id numbers for svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_LAYER_ID control to set the spatial and</para>
    /// <para>temporal layer id for the current frame.</para>
    /// </remarks>
    public unsafe partial class VpxSvcLayerId : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int spatial_layer_id;

            [FieldOffset(4)]
            internal int temporal_layer_id;

            [FieldOffset(8)]
            internal fixed int temporal_layer_id_per_spatial[5];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_svc_layer_id@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcLayerId> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcLayerId>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxSvcLayerId __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcLayerId(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxSvcLayerId __CreateInstance(global::vpxmd.VpxSvcLayerId.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcLayerId(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxSvcLayerId.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcLayerId.__Internal));
            *(global::vpxmd.VpxSvcLayerId.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcLayerId(global::vpxmd.VpxSvcLayerId.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxSvcLayerId(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxSvcLayerId()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcLayerId.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxSvcLayerId(global::vpxmd.VpxSvcLayerId _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcLayerId.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxSvcLayerId.__Internal*) __Instance) = *((global::vpxmd.VpxSvcLayerId.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxSvcLayerId __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int SpatialLayerId
        {
            get
            {
                return ((global::vpxmd.VpxSvcLayerId.__Internal*) __Instance)->spatial_layer_id;
            }

            set
            {
                ((global::vpxmd.VpxSvcLayerId.__Internal*)__Instance)->spatial_layer_id = value;
            }
        }

        public int TemporalLayerId
        {
            get
            {
                return ((global::vpxmd.VpxSvcLayerId.__Internal*) __Instance)->temporal_layer_id;
            }

            set
            {
                ((global::vpxmd.VpxSvcLayerId.__Internal*)__Instance)->temporal_layer_id = value;
            }
        }

        public int[] TemporalLayerIdPerSpatial
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcLayerId.__Internal*) __Instance)->temporal_layer_id_per_spatial != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcLayerId.__Internal*) __Instance)->temporal_layer_id_per_spatial[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcLayerId.__Internal*)__Instance)->temporal_layer_id_per_spatial[i] = value[i];
                }
            }
        }
    }

    /// <summary>vp9 svc frame flag parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame flags and buffer indices for each spatial layer for</para>
    /// <para>svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_REF_FRAME_CONFIG control to set frame</para>
    /// <para>flags and buffer indices for each spatial layer for the current (super)frame.</para>
    /// </remarks>
    public unsafe partial class VpxSvcRefFrameConfig : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 240)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed int lst_fb_idx[5];

            [FieldOffset(20)]
            internal fixed int gld_fb_idx[5];

            [FieldOffset(40)]
            internal fixed int alt_fb_idx[5];

            [FieldOffset(60)]
            internal fixed int update_buffer_slot[5];

            [FieldOffset(80)]
            internal fixed int update_last[5];

            [FieldOffset(100)]
            internal fixed int update_golden[5];

            [FieldOffset(120)]
            internal fixed int update_alt_ref[5];

            [FieldOffset(140)]
            internal fixed int reference_last[5];

            [FieldOffset(160)]
            internal fixed int reference_golden[5];

            [FieldOffset(180)]
            internal fixed int reference_alt_ref[5];

            [FieldOffset(200)]
            internal fixed long duration[5];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_svc_ref_frame_config@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcRefFrameConfig> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcRefFrameConfig>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxSvcRefFrameConfig __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcRefFrameConfig(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxSvcRefFrameConfig __CreateInstance(global::vpxmd.VpxSvcRefFrameConfig.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcRefFrameConfig(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxSvcRefFrameConfig.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcRefFrameConfig.__Internal));
            *(global::vpxmd.VpxSvcRefFrameConfig.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcRefFrameConfig(global::vpxmd.VpxSvcRefFrameConfig.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxSvcRefFrameConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxSvcRefFrameConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcRefFrameConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxSvcRefFrameConfig(global::vpxmd.VpxSvcRefFrameConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcRefFrameConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance) = *((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxSvcRefFrameConfig __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] LstFbIdx
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->lst_fb_idx != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->lst_fb_idx[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->lst_fb_idx[i] = value[i];
                }
            }
        }

        public int[] GldFbIdx
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->gld_fb_idx != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->gld_fb_idx[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->gld_fb_idx[i] = value[i];
                }
            }
        }

        public int[] AltFbIdx
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->alt_fb_idx != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->alt_fb_idx[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->alt_fb_idx[i] = value[i];
                }
            }
        }

        public int[] UpdateBufferSlot
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_buffer_slot != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_buffer_slot[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->update_buffer_slot[i] = value[i];
                }
            }
        }

        public int[] UpdateLast
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_last != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_last[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->update_last[i] = value[i];
                }
            }
        }

        public int[] UpdateGolden
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_golden != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_golden[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->update_golden[i] = value[i];
                }
            }
        }

        public int[] UpdateAltRef
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_alt_ref != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->update_alt_ref[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->update_alt_ref[i] = value[i];
                }
            }
        }

        public int[] ReferenceLast
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->reference_last != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->reference_last[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->reference_last[i] = value[i];
                }
            }
        }

        public int[] ReferenceGolden
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->reference_golden != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->reference_golden[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->reference_golden[i] = value[i];
                }
            }
        }

        public int[] ReferenceAltRef
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->reference_alt_ref != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->reference_alt_ref[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->reference_alt_ref[i] = value[i];
                }
            }
        }

        public long[] Duration
        {
            get
            {
                long[] __value = null;
                if (((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->duration != null)
                {
                    __value = new long[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*) __Instance)->duration[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcRefFrameConfig.__Internal*)__Instance)->duration[i] = value[i];
                }
            }
        }
    }

    /// <summary>vp9 svc frame dropping parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame drop thresholds for each spatial layer, and</para>
    /// <para>the frame dropping mode: 0 = layer based frame dropping (default),</para>
    /// <para>1 = constrained dropping where current layer drop forces all upper</para>
    /// <para>spatial layers to drop.</para>
    /// </remarks>
    public unsafe partial class VpxSvcFrameDrop : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed int framedrop_thresh[5];

            [FieldOffset(20)]
            internal global::vpxmd.SVC_LAYER_DROP_MODE framedrop_mode;

            [FieldOffset(24)]
            internal int max_consec_drop;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_svc_frame_drop@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcFrameDrop> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcFrameDrop>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxSvcFrameDrop __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcFrameDrop(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxSvcFrameDrop __CreateInstance(global::vpxmd.VpxSvcFrameDrop.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcFrameDrop(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxSvcFrameDrop.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcFrameDrop.__Internal));
            *(global::vpxmd.VpxSvcFrameDrop.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcFrameDrop(global::vpxmd.VpxSvcFrameDrop.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxSvcFrameDrop(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxSvcFrameDrop()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcFrameDrop.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxSvcFrameDrop(global::vpxmd.VpxSvcFrameDrop _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcFrameDrop.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxSvcFrameDrop.__Internal*) __Instance) = *((global::vpxmd.VpxSvcFrameDrop.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxSvcFrameDrop __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FramedropThresh
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcFrameDrop.__Internal*) __Instance)->framedrop_thresh != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcFrameDrop.__Internal*) __Instance)->framedrop_thresh[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcFrameDrop.__Internal*)__Instance)->framedrop_thresh[i] = value[i];
                }
            }
        }

        public global::vpxmd.SVC_LAYER_DROP_MODE FramedropMode
        {
            get
            {
                return ((global::vpxmd.VpxSvcFrameDrop.__Internal*) __Instance)->framedrop_mode;
            }

            set
            {
                ((global::vpxmd.VpxSvcFrameDrop.__Internal*)__Instance)->framedrop_mode = value;
            }
        }

        public int MaxConsecDrop
        {
            get
            {
                return ((global::vpxmd.VpxSvcFrameDrop.__Internal*) __Instance)->max_consec_drop;
            }

            set
            {
                ((global::vpxmd.VpxSvcFrameDrop.__Internal*)__Instance)->max_consec_drop = value;
            }
        }
    }

    /// <summary>vp9 svc spatial layer sync parameters.</summary>
    /// <remarks>This defines the spatial layer sync flag, defined per spatial layer.</remarks>
    public unsafe partial class VpxSvcSpatialLayerSync : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed int spatial_layer_sync[5];

            [FieldOffset(20)]
            internal int base_layer_intra_only;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_svc_spatial_layer_sync@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcSpatialLayerSync> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxSvcSpatialLayerSync>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxSvcSpatialLayerSync __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcSpatialLayerSync(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxSvcSpatialLayerSync __CreateInstance(global::vpxmd.VpxSvcSpatialLayerSync.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxSvcSpatialLayerSync(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxSvcSpatialLayerSync.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcSpatialLayerSync.__Internal));
            *(global::vpxmd.VpxSvcSpatialLayerSync.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcSpatialLayerSync(global::vpxmd.VpxSvcSpatialLayerSync.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxSvcSpatialLayerSync(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxSvcSpatialLayerSync()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcSpatialLayerSync.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxSvcSpatialLayerSync(global::vpxmd.VpxSvcSpatialLayerSync _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxSvcSpatialLayerSync.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxSvcSpatialLayerSync.__Internal*) __Instance) = *((global::vpxmd.VpxSvcSpatialLayerSync.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxSvcSpatialLayerSync __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] SpatialLayerSync
        {
            get
            {
                int[] __value = null;
                if (((global::vpxmd.VpxSvcSpatialLayerSync.__Internal*) __Instance)->spatial_layer_sync != null)
                {
                    __value = new int[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::vpxmd.VpxSvcSpatialLayerSync.__Internal*) __Instance)->spatial_layer_sync[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::vpxmd.VpxSvcSpatialLayerSync.__Internal*)__Instance)->spatial_layer_sync[i] = value[i];
                }
            }
        }

        public int BaseLayerIntraOnly
        {
            get
            {
                return ((global::vpxmd.VpxSvcSpatialLayerSync.__Internal*) __Instance)->base_layer_intra_only;
            }

            set
            {
                ((global::vpxmd.VpxSvcSpatialLayerSync.__Internal*)__Instance)->base_layer_intra_only = value;
            }
        }
    }

    public unsafe partial class vp8cx
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_vp8_cx")]
            internal static extern global::System.IntPtr VpxCodecVp8Cx();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_vp9_cx")]
            internal static extern global::System.IntPtr VpxCodecVp9Cx();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_FRAME_FLAGS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_FRAME_FLAGS(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_ID@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_TEMPORAL_LAYER_ID(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_ROI_MAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_roi_map@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ROI_MAP(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_ROI_MAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_roi_map@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_ROI_MAP(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_ACTIVEMAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_active_map@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ACTIVEMAP(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_SCALEMODE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_scaling_mode@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_SCALEMODE(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC_PARAMETERS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAX@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_PARAMETERS(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_REGISTER_CX_CALLBACK@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAX@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_REGISTER_CX_CALLBACK(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC_LAYER_ID@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_layer_id@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_LAYER_ID(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_CPUUSED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_CPUUSED(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ENABLEAUTOALTREF(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_NOISE_SENSITIVITY(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_SHARPNESS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_SHARPNESS(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_STATIC_THRESHOLD@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_STATIC_THRESHOLD(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_TOKEN_PARTITIONS(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_MAXFRAMES(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_ARNR_STRENGTH@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_STRENGTH(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_ARNR_TYPE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_TYPE(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_TUNING@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_TUNING(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_CQ_LEVEL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_CQ_LEVEL(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_TILE_COLUMNS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_COLUMNS(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_TILE_ROWS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_ROWS(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_TPL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TPL(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_GET_LAST_QUANTIZER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER_64(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_GET_SVC_LAYER_ID@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_layer_id@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_LAYER_ID(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_MAX_INTRA_BITRATE_PCT(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_INTER_BITRATE_PCT(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_GF_CBR_BOOST_PCT(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_SCREEN_CONTENT_MODE(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_GF_CBR_BOOST_PCT(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_LOSSLESS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_LOSSLESS(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODING@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PARALLEL_DECODING(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_AQ_MODE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_AQ_MODE(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_ALT_REF_AQ@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_ALT_REF_AQ(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOST@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PERIODIC_BOOST(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_NOISE_SENSITIVITY@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_NOISE_SENSITIVITY(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_TUNE_CONTENT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TUNE_CONTENT(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_COLOR_SPACE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_SPACE(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_MIN_GF_INTERVAL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_MIN_GF_INTERVAL(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_MAX_GF_INTERVAL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_GF_INTERVAL(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_GET_ACTIVEMAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_active_map@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_ACTIVEMAP(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_COLOR_RANGE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_RANGE(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIG@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_ref_frame_config@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_REF_FRAME_CONFIG(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_RENDER_SIZE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_RENDER_SIZE(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_TARGET_LEVEL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TARGET_LEVEL(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_ROW_MT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_ROW_MT(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_GET_LEVEL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_LEVEL(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PRED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_INTER_LAYER_PRED(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_frame_drop@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_FRAME_DROP_LAYER(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIG@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_ref_frame_config@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_REF_FRAME_CONFIG(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REF@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_GF_TEMPORAL_REF(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNC@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_spatial_layer_sync@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_SPATIAL_LAYER_SYNC(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_POSTENCODE_DROP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_POSTENCODE_DROP(global::System.IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9E_SET_DELTA_Q_UV@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_DELTA_Q_UV(global::System.IntPtr _0, int _1, int _2);
        }

        public static global::vpxmd.VpxCodecIface VpxCodecVp8Cx()
        {
            var __ret = __Internal.VpxCodecVp8Cx();
            global::vpxmd.VpxCodecIface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxCodecIface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxCodecIface) global::vpxmd.VpxCodecIface.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxCodecIface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::vpxmd.VpxCodecIface VpxCodecVp9Cx()
        {
            var __ret = __Internal.VpxCodecVp9Cx();
            global::vpxmd.VpxCodecIface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxCodecIface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxCodecIface) global::vpxmd.VpxCodecIface.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxCodecIface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_FRAME_FLAGS(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_FRAME_FLAGS(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_TEMPORAL_LAYER_ID(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_TEMPORAL_LAYER_ID(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ROI_MAP(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxRoiMap _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_ROI_MAP(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_ROI_MAP(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxRoiMap _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_ROI_MAP(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ACTIVEMAP(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxActiveMap _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_ACTIVEMAP(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_SCALEMODE(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxScalingMode _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_SCALEMODE(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_PARAMETERS(global::vpxmd.VpxCodecCtx _0, int _1, global::System.IntPtr _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC_PARAMETERS(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_REGISTER_CX_CALLBACK(global::vpxmd.VpxCodecCtx _0, int _1, global::System.IntPtr _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_REGISTER_CX_CALLBACK(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_LAYER_ID(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxSvcLayerId _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC_LAYER_ID(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_CPUUSED(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_CPUUSED(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ENABLEAUTOALTREF(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_ENABLEAUTOALTREF(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_NOISE_SENSITIVITY(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_NOISE_SENSITIVITY(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_SHARPNESS(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_SHARPNESS(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_STATIC_THRESHOLD(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_STATIC_THRESHOLD(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_TOKEN_PARTITIONS(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_TOKEN_PARTITIONS(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_MAXFRAMES(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_ARNR_MAXFRAMES(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_STRENGTH(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_ARNR_STRENGTH(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_TYPE(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_ARNR_TYPE(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_TUNING(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_TUNING(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_CQ_LEVEL(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_CQ_LEVEL(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_COLUMNS(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_TILE_COLUMNS(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_ROWS(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_TILE_ROWS(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TPL(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_TPL(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP8E_GET_LAST_QUANTIZER(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER_64(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP8E_GET_LAST_QUANTIZER_64(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_LAYER_ID(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxSvcLayerId _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_GET_SVC_LAYER_ID(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_MAX_INTRA_BITRATE_PCT(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_MAX_INTRA_BITRATE_PCT(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_INTER_BITRATE_PCT(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_MAX_INTER_BITRATE_PCT(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_GF_CBR_BOOST_PCT(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_GF_CBR_BOOST_PCT(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8E_SET_SCREEN_CONTENT_MODE(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP8E_SET_SCREEN_CONTENT_MODE(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_GF_CBR_BOOST_PCT(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_GF_CBR_BOOST_PCT(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_LOSSLESS(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_LOSSLESS(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PARALLEL_DECODING(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_FRAME_PARALLEL_DECODING(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_AQ_MODE(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_AQ_MODE(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_ALT_REF_AQ(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_ALT_REF_AQ(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PERIODIC_BOOST(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_FRAME_PERIODIC_BOOST(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_NOISE_SENSITIVITY(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_NOISE_SENSITIVITY(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TUNE_CONTENT(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_TUNE_CONTENT(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_SPACE(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_COLOR_SPACE(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_MIN_GF_INTERVAL(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_MIN_GF_INTERVAL(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_GF_INTERVAL(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_MAX_GF_INTERVAL(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_ACTIVEMAP(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxActiveMap _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_GET_ACTIVEMAP(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_RANGE(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_COLOR_RANGE(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_REF_FRAME_CONFIG(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxSvcRefFrameConfig _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC_REF_FRAME_CONFIG(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_RENDER_SIZE(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP9E_SET_RENDER_SIZE(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_TARGET_LEVEL(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_TARGET_LEVEL(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_ROW_MT(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_ROW_MT(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_LEVEL(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP9E_GET_LEVEL(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_INTER_LAYER_PRED(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC_INTER_LAYER_PRED(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_FRAME_DROP_LAYER(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxSvcFrameDrop _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC_FRAME_DROP_LAYER(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_REF_FRAME_CONFIG(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxSvcRefFrameConfig _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_GET_SVC_REF_FRAME_CONFIG(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_GF_TEMPORAL_REF(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC_GF_TEMPORAL_REF(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_SPATIAL_LAYER_SYNC(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxSvcSpatialLayerSync _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_SVC_SPATIAL_LAYER_SYNC(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_POSTENCODE_DROP(global::vpxmd.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_POSTENCODE_DROP(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9E_SET_DELTA_Q_UV(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9E_SET_DELTA_Q_UV(__arg0, _1, _2);
            return __ret;
        }

        /// <summary>
        /// <para>This interface provides the capability to encode raw VP8 streams.</para>
        /// <para>@{</para>
        /// </summary>
        public static global::vpxmd.VpxCodecIface VpxCodecVp8CxAlgo
        {
            get
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp8_cx_algo");
                return global::vpxmd.VpxCodecIface.__CreateInstance(*__ptr);
            }

            set
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp8_cx_algo");
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                *__ptr = *(global::vpxmd.VpxCodecIface.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>This interface provides the capability to encode raw VP9 streams.</para>
        /// <para>@{</para>
        /// </summary>
        public static global::vpxmd.VpxCodecIface VpxCodecVp9CxAlgo
        {
            get
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp9_cx_algo");
                return global::vpxmd.VpxCodecIface.__CreateInstance(*__ptr);
            }

            set
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp9_cx_algo");
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                *__ptr = *(global::vpxmd.VpxCodecIface.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Control functions</summary>
    /// <remarks>The set of macros define the control functions of VP8 interface</remarks>
    public enum Vp8ComControlId
    {
        /// <summary>pass in an external frame into decoder to be used as reference frame</summary>
        VP8SET_REFERENCE = 1,
        /// <summary>get a copy of reference frame from the decoder</summary>
        VP8COPY_REFERENCE = 2,
        /// <summary>set the decoder's post processing settings</summary>
        VP8SET_POSTPROC = 3,
        /// <summary>get a pointer to a reference frame</summary>
        VP9GET_REFERENCE = 128,
        VP8COMMON_CTRL_ID_MAX = 129,
        VP8DECODER_CTRL_ID_START = 256
    }

    /// <summary>post process flags</summary>
    /// <remarks>The set of macros define VP8 decoder post processing flags</remarks>
    [Flags]
    public enum Vp8PostprocLevel
    {
        VP8NOFILTERING = 0,
        VP8DEBLOCK = 1,
        VP8DEMACROBLOCK = 2,
        VP8ADDNOISE = 4,
        VP8MFQE = 8
    }

    /// <summary>reference frame type</summary>
    /// <remarks>The set of macros define the type of VP8 reference frames</remarks>
    [Flags]
    public enum VpxRefFrameType
    {
        VP8LAST_FRAME = 1,
        VP8GOLD_FRAME = 2,
        VP8ALTR_FRAME = 4
    }

    /// <summary>post process flags</summary>
    /// <remarks>
    /// <para>This define a structure that describe the post processing settings. For</para>
    /// <para>the best objective measure (using the PSNR metric) set post_proc_flag</para>
    /// <para>to VP8_DEBLOCK and deblocking_level to 1.</para>
    /// </remarks>
    /// <summary>reference frame type</summary>
    /// <remarks>The set of macros define the type of VP8 reference frames</remarks>
    /// <summary>reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp8 reference frames.</remarks>
    /// <summary>VP9 specific reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp9 reference frames.</remarks>
    /// <summary>post process flags</summary>
    /// <remarks>
    /// <para>This define a structure that describe the post processing settings. For</para>
    /// <para>the best objective measure (using the PSNR metric) set post_proc_flag</para>
    /// <para>to VP8_DEBLOCK and deblocking_level to 1.</para>
    /// </remarks>
    public unsafe partial class Vp8PostprocCfg : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int post_proc_flag;

            [FieldOffset(4)]
            internal int deblocking_level;

            [FieldOffset(8)]
            internal int noise_level;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vp8_postproc_cfg@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.Vp8PostprocCfg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.Vp8PostprocCfg>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.Vp8PostprocCfg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.Vp8PostprocCfg(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.Vp8PostprocCfg __CreateInstance(global::vpxmd.Vp8PostprocCfg.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.Vp8PostprocCfg(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.Vp8PostprocCfg.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.Vp8PostprocCfg.__Internal));
            *(global::vpxmd.Vp8PostprocCfg.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vp8PostprocCfg(global::vpxmd.Vp8PostprocCfg.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vp8PostprocCfg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Vp8PostprocCfg()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.Vp8PostprocCfg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Vp8PostprocCfg(global::vpxmd.Vp8PostprocCfg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.Vp8PostprocCfg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.Vp8PostprocCfg.__Internal*) __Instance) = *((global::vpxmd.Vp8PostprocCfg.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.Vp8PostprocCfg __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int PostProcFlag
        {
            get
            {
                return ((global::vpxmd.Vp8PostprocCfg.__Internal*) __Instance)->post_proc_flag;
            }

            set
            {
                ((global::vpxmd.Vp8PostprocCfg.__Internal*)__Instance)->post_proc_flag = value;
            }
        }

        public int DeblockingLevel
        {
            get
            {
                return ((global::vpxmd.Vp8PostprocCfg.__Internal*) __Instance)->deblocking_level;
            }

            set
            {
                ((global::vpxmd.Vp8PostprocCfg.__Internal*)__Instance)->deblocking_level = value;
            }
        }

        public int NoiseLevel
        {
            get
            {
                return ((global::vpxmd.Vp8PostprocCfg.__Internal*) __Instance)->noise_level;
            }

            set
            {
                ((global::vpxmd.Vp8PostprocCfg.__Internal*)__Instance)->noise_level = value;
            }
        }
    }

    /// <summary>reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp8 reference frames.</remarks>
    public unsafe partial class VpxRefFrame : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::vpxmd.VpxRefFrameType frame_type;

            [FieldOffset(8)]
            internal global::vpxmd.VpxImage.__Internal img;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_ref_frame@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxRefFrame> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxRefFrame>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxRefFrame __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxRefFrame(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxRefFrame __CreateInstance(global::vpxmd.VpxRefFrame.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxRefFrame(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxRefFrame.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRefFrame.__Internal));
            *(global::vpxmd.VpxRefFrame.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRefFrame(global::vpxmd.VpxRefFrame.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxRefFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxRefFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRefFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxRefFrame(global::vpxmd.VpxRefFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxRefFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxRefFrame.__Internal*) __Instance) = *((global::vpxmd.VpxRefFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxRefFrame __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::vpxmd.VpxRefFrameType FrameType
        {
            get
            {
                return ((global::vpxmd.VpxRefFrame.__Internal*) __Instance)->frame_type;
            }

            set
            {
                ((global::vpxmd.VpxRefFrame.__Internal*)__Instance)->frame_type = value;
            }
        }

        public global::vpxmd.VpxImage Img
        {
            get
            {
                return global::vpxmd.VpxImage.__CreateInstance(new global::System.IntPtr(&((global::vpxmd.VpxRefFrame.__Internal*) __Instance)->img));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::vpxmd.VpxRefFrame.__Internal*)__Instance)->img = *(global::vpxmd.VpxImage.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>VP9 specific reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp9 reference frames.</remarks>
    public unsafe partial class Vp9RefFrame : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int idx;

            [FieldOffset(8)]
            internal global::vpxmd.VpxImage.__Internal img;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vp9_ref_frame@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.Vp9RefFrame> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.Vp9RefFrame>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.Vp9RefFrame __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.Vp9RefFrame(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.Vp9RefFrame __CreateInstance(global::vpxmd.Vp9RefFrame.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.Vp9RefFrame(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.Vp9RefFrame.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.Vp9RefFrame.__Internal));
            *(global::vpxmd.Vp9RefFrame.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vp9RefFrame(global::vpxmd.Vp9RefFrame.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vp9RefFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Vp9RefFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.Vp9RefFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Vp9RefFrame(global::vpxmd.Vp9RefFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.Vp9RefFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.Vp9RefFrame.__Internal*) __Instance) = *((global::vpxmd.Vp9RefFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.Vp9RefFrame __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Idx
        {
            get
            {
                return ((global::vpxmd.Vp9RefFrame.__Internal*) __Instance)->idx;
            }

            set
            {
                ((global::vpxmd.Vp9RefFrame.__Internal*)__Instance)->idx = value;
            }
        }

        public global::vpxmd.VpxImage Img
        {
            get
            {
                return global::vpxmd.VpxImage.__CreateInstance(new global::System.IntPtr(&((global::vpxmd.Vp9RefFrame.__Internal*) __Instance)->img));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::vpxmd.Vp9RefFrame.__Internal*)__Instance)->img = *(global::vpxmd.VpxImage.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class vp8
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8_SET_REFERENCE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_ref_frame@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8SET_REFERENCE(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8_COPY_REFERENCE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_ref_frame@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8COPY_REFERENCE(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8_SET_POSTPROC@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvp8_postproc_cfg@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8SET_POSTPROC(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9_GET_REFERENCE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvp9_ref_frame@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9GET_REFERENCE(global::System.IntPtr _0, int _1, global::System.IntPtr _2);
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8SET_REFERENCE(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxRefFrame _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP8SET_REFERENCE(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8COPY_REFERENCE(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxRefFrame _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP8COPY_REFERENCE(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8SET_POSTPROC(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.Vp8PostprocCfg _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP8SET_POSTPROC(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9GET_REFERENCE(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.Vp9RefFrame _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP9GET_REFERENCE(__arg0, _1, __arg2);
            return __ret;
        }
    }

    /// <summary>VP8 decoder control functions</summary>
    /// <remarks>
    /// <para>This set of macros define the control functions available for the VP8</para>
    /// <para>decoder interface.</para>
    /// <para>#vpx_codec_control</para>
    /// </remarks>
    public enum Vp8DecControlId
    {
        /// <summary>
        /// <para>control function to get info on which reference frames were updated</para>
        /// <para>by the last decode</para>
        /// </summary>
        VP8D_GET_LAST_REF_UPDATES = 256,
        /// <summary>check if the indicated frame is corrupted</summary>
        VP8D_GET_FRAME_CORRUPTED = 257,
        /// <summary>
        /// <para>control function to get info on which reference frames were used</para>
        /// <para>by the last decode</para>
        /// </summary>
        VP8D_GET_LAST_REF_USED = 258,
        /// <summary>
        /// <para>decryption function to decrypt encoded buffer data immediately</para>
        /// <para>before decoding. Takes a vpx_decrypt_init, which contains</para>
        /// <para>a callback function and opaque context pointer.</para>
        /// </summary>
        VPXD_SET_DECRYPTOR = 259,
        /// <summary>
        /// <para>decryption function to decrypt encoded buffer data immediately</para>
        /// <para>before decoding. Takes a vpx_decrypt_init, which contains</para>
        /// <para>a callback function and opaque context pointer.</para>
        /// </summary>
        VP8D_SET_DECRYPTOR = 259,
        /// <summary>
        /// <para>control function to get the dimensions that the current frame is decoded</para>
        /// <para>at. This may be different to the intended display size for the frame as</para>
        /// <para>specified in the wrapper or frame header (see VP9D_GET_DISPLAY_SIZE).</para>
        /// </summary>
        VP9D_GET_FRAME_SIZE = 260,
        /// <summary>
        /// <para>control function to get the current frame's intended display dimensions</para>
        /// <para>(as specified in the wrapper or frame header). This may be different to</para>
        /// <para>the decoded dimensions of this frame (see VP9D_GET_FRAME_SIZE).</para>
        /// </summary>
        VP9D_GET_DISPLAY_SIZE = 261,
        /// <summary>control function to get the bit depth of the stream.</summary>
        VP9D_GET_BIT_DEPTH = 262,
        /// <summary>
        /// <para>control function to set the byte alignment of the planes in the reference</para>
        /// <para>buffers. Valid values are power of 2, from 32 to 1024. A value of 0 sets</para>
        /// <para>legacy alignment. I.e. Y plane is aligned to 32 bytes, U plane directly</para>
        /// <para>follows Y plane, and V plane directly follows U plane. Default value is 0.</para>
        /// </summary>
        VP9SET_BYTE_ALIGNMENT = 263,
        /// <summary>
        /// <para>control function to invert the decoding order to from right to left. The</para>
        /// <para>function is used in a test to confirm the decoding independence of tile</para>
        /// <para>columns. The function may be used in application where this order</para>
        /// <para>of decoding is desired.</para>
        /// </summary>
        /// <remarks>
        /// <para>TODO(yaowu): Rework the unit test that uses this control, and in a future</para>
        /// <para>release, this test-only control shall be removed.</para>
        /// </remarks>
        VP9INVERT_TILE_DECODE_ORDER = 264,
        /// <summary>
        /// <para>control function to set the skip loop filter flag. Valid values are</para>
        /// <para>integers. The decoder will skip the loop filter when its value is set to</para>
        /// <para>nonzero. If the loop filter is skipped the decoder may accumulate decode</para>
        /// <para>artifacts. The default value is 0.</para>
        /// </summary>
        VP9SET_SKIP_LOOP_FILTER = 265,
        /// <summary>
        /// <para>control function to decode SVC stream up to the x spatial layers,</para>
        /// <para>where x is passed in through the control, and is 0 for base layer.</para>
        /// </summary>
        VP9DECODE_SVC_SPATIAL_LAYER = 266,
        /// <summary>Codec control function to get last decoded frame quantizer.</summary>
        /// <remarks>
        /// <para>Return value uses internal quantizer scale defined by the codec.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VPXD_GET_LAST_QUANTIZER = 267,
        /// <summary>Codec control function to set row level multi-threading.</summary>
        /// <remarks>
        /// <para>0 : off, 1 : on</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9D_SET_ROW_MT = 268,
        /// <summary>Codec control function to set loopfilter optimization.</summary>
        /// <remarks>
        /// <para>0 : off, Loop filter is done after all tiles have been decoded</para>
        /// <para>1 : on, Loop filter is done immediately after decode without</para>
        /// <para>waiting for all threads to sync.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9D_SET_LOOP_FILTER_OPT = 269,
        /// <summary>Codec control function to set loopfilter optimization.</summary>
        /// <remarks>
        /// <para>0 : off, Loop filter is done after all tiles have been decoded</para>
        /// <para>1 : on, Loop filter is done immediately after decode without</para>
        /// <para>waiting for all threads to sync.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP8DECODER_CTRL_ID_MAX = 270
    }

    /// <summary>
    /// <para>Decrypt n bytes of data from input -&gt; output, using the decrypt_state</para>
    /// <para>passed in VPXD_SET_DECRYPTOR.</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void VpxDecryptCb(global::System.IntPtr decrypt_state, byte* input, byte* output, int count);

    /// <summary>Structure to hold decryption state</summary>
    /// <remarks>Defines a structure to hold the decryption state and access function.</remarks>
    /// <summary>Structure to hold decryption state</summary>
    /// <remarks>Defines a structure to hold the decryption state and access function.</remarks>
    public unsafe partial class VpxDecryptInit : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr decrypt_cb;

            [FieldOffset(8)]
            internal global::System.IntPtr decrypt_state;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vpx_decrypt_init@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxDecryptInit> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::vpxmd.VpxDecryptInit>();

        protected bool __ownsNativeInstance;

        internal static global::vpxmd.VpxDecryptInit __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxDecryptInit(native.ToPointer(), skipVTables);
        }

        internal static global::vpxmd.VpxDecryptInit __CreateInstance(global::vpxmd.VpxDecryptInit.__Internal native, bool skipVTables = false)
        {
            return new global::vpxmd.VpxDecryptInit(native, skipVTables);
        }

        private static void* __CopyValue(global::vpxmd.VpxDecryptInit.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxDecryptInit.__Internal));
            *(global::vpxmd.VpxDecryptInit.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxDecryptInit(global::vpxmd.VpxDecryptInit.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VpxDecryptInit(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VpxDecryptInit()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxDecryptInit.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VpxDecryptInit(global::vpxmd.VpxDecryptInit _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::vpxmd.VpxDecryptInit.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::vpxmd.VpxDecryptInit.__Internal*) __Instance) = *((global::vpxmd.VpxDecryptInit.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::vpxmd.VpxDecryptInit __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::vpxmd.VpxDecryptCb DecryptCb
        {
            get
            {
                var __ptr0 = ((global::vpxmd.VpxDecryptInit.__Internal*) __Instance)->decrypt_cb;
                return __ptr0 == IntPtr.Zero? null : (global::vpxmd.VpxDecryptCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::vpxmd.VpxDecryptCb));
            }

            set
            {
                ((global::vpxmd.VpxDecryptInit.__Internal*)__Instance)->decrypt_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr DecryptState
        {
            get
            {
                return ((global::vpxmd.VpxDecryptInit.__Internal*) __Instance)->decrypt_state;
            }

            set
            {
                ((global::vpxmd.VpxDecryptInit.__Internal*)__Instance)->decrypt_state = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class vp8dx
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_vp8_dx")]
            internal static extern global::System.IntPtr VpxCodecVp8Dx();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="vpx_codec_vp9_dx")]
            internal static extern global::System.IntPtr VpxCodecVp9Dx();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8D_GET_LAST_REF_UPDATES@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_UPDATES(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8D_GET_FRAME_CORRUPTED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_GET_FRAME_CORRUPTED(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8D_GET_LAST_REF_USED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_USED(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VPXD_GET_LAST_QUANTIZER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVPXD_GET_LAST_QUANTIZER(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VPXD_SET_DECRYPTOR@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_decrypt_init@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVPXD_SET_DECRYPTOR(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP8D_SET_DECRYPTOR@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_decrypt_init@@@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_SET_DECRYPTOR(global::System.IntPtr _0, int _1, global::System.IntPtr _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9D_GET_DISPLAY_SIZE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_GET_DISPLAY_SIZE(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9D_GET_BIT_DEPTH@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAI@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_GET_BIT_DEPTH(global::System.IntPtr _0, int _1, uint* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9D_GET_FRAME_SIZE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_GET_FRAME_SIZE(global::System.IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9INVERT_TILE_DECODE_ORDER(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9DECODE_SVC_SPATIAL_LAYER(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9_SET_SKIP_LOOP_FILTER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9SET_SKIP_LOOP_FILTER(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9D_SET_ROW_MT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_SET_ROW_MT(global::System.IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("vpxmd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?vpx_codec_control_VP9D_SET_LOOP_FILTER_OPT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z")]
            internal static extern global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_SET_LOOP_FILTER_OPT(global::System.IntPtr _0, int _1, int _2);
        }

        public static global::vpxmd.VpxCodecIface VpxCodecVp8Dx()
        {
            var __ret = __Internal.VpxCodecVp8Dx();
            global::vpxmd.VpxCodecIface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxCodecIface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxCodecIface) global::vpxmd.VpxCodecIface.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxCodecIface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::vpxmd.VpxCodecIface VpxCodecVp9Dx()
        {
            var __ret = __Internal.VpxCodecVp9Dx();
            global::vpxmd.VpxCodecIface __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::vpxmd.VpxCodecIface.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::vpxmd.VpxCodecIface) global::vpxmd.VpxCodecIface.NativeToManagedMap[__ret];
            else __result0 = global::vpxmd.VpxCodecIface.__CreateInstance(__ret);
            return __result0;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_UPDATES(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP8D_GET_LAST_REF_UPDATES(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_GET_FRAME_CORRUPTED(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP8D_GET_FRAME_CORRUPTED(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_USED(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP8D_GET_LAST_REF_USED(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVPXD_GET_LAST_QUANTIZER(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVPXD_GET_LAST_QUANTIZER(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVPXD_SET_DECRYPTOR(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxDecryptInit _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVPXD_SET_DECRYPTOR(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP8D_SET_DECRYPTOR(global::vpxmd.VpxCodecCtx _0, int _1, global::vpxmd.VpxDecryptInit _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __arg2 = ReferenceEquals(_2, null) ? global::System.IntPtr.Zero : _2.__Instance;
            var __ret = __Internal.VpxCodecControlVP8D_SET_DECRYPTOR(__arg0, _1, __arg2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_GET_DISPLAY_SIZE(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP9D_GET_DISPLAY_SIZE(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_GET_BIT_DEPTH(global::vpxmd.VpxCodecCtx _0, int _1, ref uint _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (uint* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP9D_GET_BIT_DEPTH(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_GET_FRAME_SIZE(global::vpxmd.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var __ret = __Internal.VpxCodecControlVP9D_GET_FRAME_SIZE(__arg0, _1, __arg2);
                return __ret;
            }
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9INVERT_TILE_DECODE_ORDER(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9INVERT_TILE_DECODE_ORDER(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9DECODE_SVC_SPATIAL_LAYER(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9DECODE_SVC_SPATIAL_LAYER(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9SET_SKIP_LOOP_FILTER(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9SET_SKIP_LOOP_FILTER(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_SET_ROW_MT(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9D_SET_ROW_MT(__arg0, _1, _2);
            return __ret;
        }

        public static global::vpxmd.VpxCodecErrT VpxCodecControlVP9D_SET_LOOP_FILTER_OPT(global::vpxmd.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.VpxCodecControlVP9D_SET_LOOP_FILTER_OPT(__arg0, _1, _2);
            return __ret;
        }

        /// <summary>
        /// <para>This interface provides the capability to decode VP8 streams.</para>
        /// <para>@{</para>
        /// </summary>
        public static global::vpxmd.VpxCodecIface VpxCodecVp8DxAlgo
        {
            get
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp8_dx_algo");
                return global::vpxmd.VpxCodecIface.__CreateInstance(*__ptr);
            }

            set
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp8_dx_algo");
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                *__ptr = *(global::vpxmd.VpxCodecIface.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>This interface provides the capability to decode VP9 streams.</para>
        /// <para>@{</para>
        /// </summary>
        public static global::vpxmd.VpxCodecIface VpxCodecVp9DxAlgo
        {
            get
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp9_dx_algo");
                return global::vpxmd.VpxCodecIface.__CreateInstance(*__ptr);
            }

            set
            {
                var __ptr = (global::vpxmd.VpxCodecIface.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("vpxmd", "vpx_codec_vp9_dx_algo");
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                *__ptr = *(global::vpxmd.VpxCodecIface.__Internal*) value.__Instance;
            }
        }
    }
}
