//-----------------------------------------------------------------------------
// Filename: DtlsUtils.cs
//
// Description: This class provides useful functions to handle certificate in 
// DTLS-SRTP.
//
// Notes: The webrtc specification provides guidelines for X509 certificate
// management:
// https://www.w3.org/TR/webrtc/#certificate-management
//
// In particular:
// "The explicit certificate management functions provided here are optional. 
// If an application does not provide the certificates configuration option 
// when constructing an RTCPeerConnection a new set of certificates MUST be 
// generated by the user agent. That set MUST include an ECDSA certificate with 
// a private key on the P-256 curve and a signature with a SHA-256 hash."
//
// Based on the above it's likely the safest algorithm to use is ECDSA rather
// than RSA (which will then result in an ECDH rather than DH exchange to
// initialise the SRTP keying material).
// https://www.w3.org/TR/WebCryptoAPI/#algorithms
//
// The recommended ECDSA curves are listed at:
// https://www.w3.org/TR/WebCryptoAPI/#ecdsa
// and are:
// - P-256, also known as secp256r1.
// - P-384, also known as secp384r1.
// - P-521, also known as secp521r1.
//
// Author(s):
// Rafael Soares (raf.csoares@kyubinteractive.com)
//
// History:
// 01 Jul 2020	Rafael Soares   Created.
// 21 Oct 2024  Aaron Clauson   Added ECDSA certificate generation.
// 30 Dec 2025  Lukas Volf      New DTLS/SRTP impl
//
// License:
// BSD 3-Clause "New" or "Revised" License, see included LICENSE.md file.
//-----------------------------------------------------------------------------

using System;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Tls;
using Org.BouncyCastle.Tls.Crypto.Impl.BC;
using Org.BouncyCastle.X509;
using Org.BouncyCastle.Tls.Crypto;
using SIPSorcery.Net.SharpSRTP.DTLS;

namespace SIPSorcery.Net
{
    public class DtlsUtils
    {
        public static (Certificate certificate, AsymmetricKeyParameter privateKey) CreateSelfSignedTlsCert(BcTlsCrypto crypto, bool useRsa = false)
        {
            return DtlsCertificateUtils.GenerateCertificate("WebRTC", DateTime.UtcNow.AddDays(-1), DateTime.UtcNow.AddDays(30), useRsa);
        }

        public static RTCDtlsFingerprint Fingerprint(string algorithm, TlsCertificate value)
        {
            return Fingerprint(new X509Certificate(value.GetEncoded()), algorithm);
        }

        public static RTCDtlsFingerprint Fingerprint(Certificate certificate)
        {
            return Fingerprint(new X509Certificate(certificate.GetCertificateAt(0).GetEncoded()));
        }

        public static RTCDtlsFingerprint Fingerprint(X509Certificate x509Certificate, string algorithm = "sha-256")
        {
            return new RTCDtlsFingerprint { algorithm = algorithm, value = DtlsCertificateUtils.Fingerprint(x509Certificate.CertificateStructure, algorithm) };
        }

        public static bool IsHashSupported(string algStr)
        {
            return DtlsCertificateUtils.IsHashSupported(algStr);
        }
    }
}
