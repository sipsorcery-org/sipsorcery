//-----------------------------------------------------------------------------
// Filename: RTCPeerConnection.cs
//
// Description: Represents a WebRTC RTCPeerConnection.
//
// Specification Soup (as of 13 Jul 2020):
// - "Session Description Protocol (SDP) Offer/Answer procedures for
//   Interactive Connectivity Establishment(ICE)" [ed: specification for
//   including ICE candidates in SDP]:
//   https://tools.ietf.org/html/rfc8839
// - "Session Description Protocol (SDP) Offer/Answer Procedures For Stream
//   Control Transmission Protocol(SCTP) over Datagram Transport Layer
//   Security(DTLS) Transport." [ed: specification for negotiating
//   data channels in SDP, this defines the SDP "sctp-port" attribute] 
//   https://tools.ietf.org/html/rfc8841
// - "SDP-based Data Channel Negotiation" [ed: not currently implemented,
//   actually seems like a big pain to implement this given it can already
//   be done in-band on the SCTP connection]:
//   https://tools.ietf.org/html/rfc8864
//
// Author(s):
// Aaron Clauson (aaron@sipsorcery.com)
//
// History:
// 04 Mar 2016	Aaron Clauson	Created.
// 25 Aug 2019  Aaron Clauson   Updated from video only to audio and video.
// 18 Jan 2020  Aaron Clauson   Combined WebRTCPeer and WebRTCSession.
// 16 Mar 2020  Aaron Clauson   Refactored to support RTCPeerConnection interface.
// 13 Jul 2020  Aaron Clauson   Added data channel support.
// 22 Mar 2021  Aaron Clauson   Refactored data channels logic for new SCTP
//                              implementation.
//
// License: 
// BSD 3-Clause "New" or "Revised" License, see included LICENSE.md file.
//-----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Org.BouncyCastle.Tls;
using Org.BouncyCastle.Tls.Crypto.Impl.BC;
using SIPSorcery.Net.SharpSRTP.DTLS;
using SIPSorcery.Net.SharpSRTP.DTLSSRTP;
using SIPSorcery.SIP.App;
using SIPSorcery.Sys;

namespace SIPSorcery.Net;

/// <summary>
/// Initialiser for the RTCSessionDescription instance.
/// </summary>
/// <remarks>
/// As specified in https://www.w3.org/TR/webrtc/#rtcsessiondescription-class.
/// </remarks>
public class RTCSessionDescriptionInit
{
    /// <summary>
    /// The type of the Session Description.
    /// </summary>
    [JsonPropertyName("type")]
    public required RTCSdpType type { get; init; }

    /// <summary>
    /// A string representation of the Session Description.
    /// </summary>
    [JsonPropertyName("sdp")]
    public required string sdp { get; init; }

    public string toJSON()
    {
        return JsonSerializer.Serialize(this, SipSorceryJsonSerializerContext.Default.RTCSessionDescriptionInit);
    }

    public static bool TryParse(string json, [NotNullWhen(true)] out RTCSessionDescriptionInit? init)
    {
        init = null;

        if (string.IsNullOrWhiteSpace(json))
        {
            return false;
        }
        else
        {
            init = JsonSerializer.Deserialize<RTCSessionDescriptionInit>(json, SipSorceryJsonSerializerContext.Default.RTCSessionDescriptionInit);

            // To qualify as parsed all required fields must be set.
            return init is { } &&
                init.sdp is { };
        }
    }
}

/// <summary>
/// Represents a WebRTC RTCPeerConnection.
/// </summary>
/// <remarks>
/// Interface is defined in https://www.w3.org/TR/webrtc/#interface-definition.
/// The Session Description offer/answer mechanisms are detailed in
/// https://tools.ietf.org/html/rfc8829 "JavaScript Session Establishment Protocol (JSEP)".
/// </remarks>
public class RTCPeerConnection : RTPSession, IRTCPeerConnection
{
    // SDP constants.
    //private new const string RTP_MEDIA_PROFILE = "RTP/SAVP";
    private const string RTP_MEDIA_NON_FEEDBACK_PROFILE = "UDP/TLS/RTP/SAVP";
    private const string RTP_MEDIA_FEEDBACK_PROFILE = "UDP/TLS/RTP/SAVPF";
    private const string RTP_MEDIA_DATACHANNEL_DTLS_PROFILE = "DTLS/SCTP"; // Legacy.
    private const string RTP_MEDIA_DATACHANNEL_UDPDTLS_PROFILE = "UDP/DTLS/SCTP";
    private const string SDP_DATACHANNEL_FORMAT_ID = "webrtc-datachannel";
    private const string RTCP_MUX_ATTRIBUTE = "a=rtcp-mux";    // Indicates the media announcement is using multiplexed RTCP.
    private const string BUNDLE_ATTRIBUTE = "BUNDLE";
    private const string ICE_OPTIONS = "ice2,trickle";          // Supported ICE options.
    private const string NORMAL_CLOSE_REASON = "normal";
    private const ushort SCTP_DEFAULT_PORT = 5000;

    /// <summary>
    /// The period to wait for the SCTP association to complete before giving up.
    /// In theory this should be very quick as the DTLS connection should already have been established
    /// and the SCTP logic only needs to send the small handshake messages to establish
    /// the association.
    /// </summary>
    private const int SCTP_ASSOCIATE_TIMEOUT_SECONDS = 2;

    private new readonly string RTP_MEDIA_PROFILE = RTP_MEDIA_NON_FEEDBACK_PROFILE;
    private readonly string RTCP_ATTRIBUTE = $"a=rtcp:{SDP.IGNORE_RTP_PORT_NUMBER} IN IP4 0.0.0.0";

    public string SessionID { get; private set; }
    public string? SdpSessionID { get; private set; }
    public string LocalSdpSessionID { get; private set; }

    private RtpIceChannel _rtpIceChannel;

    private readonly RTCDataChannelCollection _dataChannels;
    public IReadOnlyCollection<RTCDataChannel> DataChannels => _dataChannels;

    private Org.BouncyCastle.Tls.Certificate _dtlsCertificate;
    private Org.BouncyCastle.Crypto.AsymmetricKeyParameter? _dtlsPrivateKey;
    private BcTlsCrypto _crypto;
    private DtlsSrtpTransport? _dtlsHandle;
    private Task _iceInitiateGatheringTask;
    private readonly TaskCompletionSource<bool> _iceCompletedGatheringTask = new();

    private Dictionary<string, int>? _rtpExtensionsUsed; // < Uri, Id>

    /// <summary>
    /// Local ICE candidates that have been supplied directly by the application.
    /// Useful for cases where the application may has extra information about the
    /// network set up such as 1:1 NATs as used by Azure and AWS.
    /// </summary>
    private List<RTCIceCandidate> _applicationIceCandidates = new List<RTCIceCandidate>();

    /// <summary>
    /// The ICE role the peer is acting in.
    /// </summary>
    public IceRolesEnum IceRole { get; set; } = IceRolesEnum.actpass;

    /// <summary>
    /// The DTLS fingerprint supplied by the remote peer in their SDP. Needs to be checked
    /// that the certificate supplied during the DTLS handshake matches.
    /// </summary>
    public RTCDtlsFingerprint? RemotePeerDtlsFingerprint { get; private set; }

    public string DtlsCertificateSignatureAlgorithm { get; private set; } = string.Empty;

    public bool IsDtlsNegotiationComplete { get; private set; }

    public RTCSessionDescription? localDescription { get; private set; }

    public RTCSessionDescription? remoteDescription { get; private set; }

    public RTCSessionDescription? currentLocalDescription => localDescription;

    public RTCSessionDescription? pendingLocalDescription => null;

    public RTCSessionDescription? currentRemoteDescription => remoteDescription;

    public RTCSessionDescription? pendingRemoteDescription => null;

    public RTCSignalingState signalingState { get; private set; } = RTCSignalingState.closed;

    public RTCIceGatheringState iceGatheringState
    {
        get
        {
            return _rtpIceChannel is { } ? _rtpIceChannel.IceGatheringState : RTCIceGatheringState.@new;
        }
    }

    public RTCIceConnectionState iceConnectionState
    {
        get
        {
            return _rtpIceChannel is { } ? _rtpIceChannel.IceConnectionState : RTCIceConnectionState.@new;
        }
    }

    public RTCPeerConnectionState connectionState { get; private set; } = RTCPeerConnectionState.@new;

    public bool canTrickleIceCandidates { get => true; }

    private RTCConfiguration _configuration;

    /// <summary>
    /// The fingerprint of the certificate being used to negotiate the DTLS handshake with the 
    /// remote peer.
    /// </summary>
    public RTCDtlsFingerprint DtlsCertificateFingerprint { get; private set; }

    /// <summary>
    /// The SCTP transport over which SCTP data is sent and received.
    /// </summary>
    /// <remarks>
    /// WebRTC API definition:
    /// https://www.w3.org/TR/webrtc/#attributes-15
    /// </remarks>
    public RTCSctpTransport sctp { get; private set; }

    /// <summary>
    /// Informs the application that session negotiation needs to be done (i.e. a createOffer call 
    /// followed by setLocalDescription).
    /// </summary>
    public event Action? onnegotiationneeded;

    private event Action<RTCIceCandidate>? _onIceCandidate;
    /// <summary>
    /// A new ICE candidate is available for the Peer Connection.
    /// </summary>
    public event Action<RTCIceCandidate> onicecandidate
    {
        add
        {
            var notifyIce = _onIceCandidate is null && value is { };
            _onIceCandidate += value;
            if (notifyIce)
            {
                foreach (var ice in _rtpIceChannel.Candidates)
                {
                    _onIceCandidate?.Invoke(ice);
                }
            }
        }
        remove
        {
            _onIceCandidate -= value;
        }
    }

    protected CancellationTokenSource? _cancellationSource = new CancellationTokenSource();
    protected object _renegotiationLock = new object();
    protected volatile bool _requireRenegotiation = true;

    public override bool RequireRenegotiation
    {
        get
        {
            return _requireRenegotiation;
        }

        protected internal set
        {
            lock (_renegotiationLock)
            {
                _requireRenegotiation = value;
                //Remove Remote Description
                if (_requireRenegotiation)
                {
                    RemoteDescription = null;
                }
            }

            //Remove NegotiationTask when state not stable
            if (!_requireRenegotiation || signalingState != RTCSignalingState.stable)
            {
                CancelOnNegotiationNeededTask();
            }
            //Call Renegotiation Delayed (We need to wait as user can try add multiple tracks in sequence)
            else
            {
                StartOnNegotiationNeededTask();
            }
        }
    }

    /// <summary>
    /// A failure occurred when gathering ICE candidates.
    /// </summary>
    public event Action<RTCIceCandidate?, string>? onicecandidateerror;

    /// <summary>
    /// The signaling state has changed. This state change is the result of either setLocalDescription or 
    /// setRemoteDescription being invoked.
    /// </summary>
    public event Action? onsignalingstatechange;

    /// <summary>
    /// This Peer Connection's ICE connection state has changed.
    /// </summary>
    public event Action<RTCIceConnectionState>? oniceconnectionstatechange;

    /// <summary>
    /// This Peer Connection's ICE gathering state has changed.
    /// </summary>
    public event Action<RTCIceGatheringState>? onicegatheringstatechange;

    /// <summary>
    /// The state of the peer connection. A state of connected means the ICE checks have 
    /// succeeded and the DTLS handshake has completed. Once in the connected state it's
    /// suitable for media packets can be exchanged.
    /// </summary>
    public event Action<RTCPeerConnectionState>? onconnectionstatechange;

    /// <summary>
    /// Fires when a new data channel is created by the remote peer.
    /// </summary>
    public event Action<RTCDataChannel>? ondatachannel;

    /// <summary>
    /// Constructor to create a new RTC peer connection instance.
    /// </summary>
    public RTCPeerConnection() :
        this(null)
    { }

    /// <summary>
    /// Constructor to create a new RTC peer connection instance.
    /// </summary>
    /// <param name="configuration">Optional.</param>
    public RTCPeerConnection(RTCConfiguration? configuration, int bindPort = 0, PortRange? portRange = null, bool videoAsPrimary = false) :
        base(true, true, true, configuration?.X_BindAddress, bindPort, portRange)
    {
        _crypto = new BcTlsCrypto();
        _dataChannels = new RTCDataChannelCollection(useEvenIds: () =>
        {
            Debug.Assert(_dtlsHandle is { });
            return _dtlsHandle.IsClient;
        });

        if (_configuration is { } &&
           _configuration.iceTransportPolicy == RTCIceTransportPolicy.relay &&
           _configuration.iceServers?.Count == 0)
        {
            throw new SipSorceryException("RTCPeerConnection must have at least one ICE server specified for a relay only transport policy.");
        }

        if (configuration is { })
        {
            _configuration = configuration;

            if (!InitializeCertificates(configuration))
            {
                logger.LogWebRtcNoCertificate();
            }

            if (_configuration.X_UseRtpFeedbackProfile)
            {
                RTP_MEDIA_PROFILE = RTP_MEDIA_FEEDBACK_PROFILE;
            }
        }
        else
        {
            _configuration = new RTCConfiguration();
        }

        if (_dtlsCertificate is null)
        {
            // No certificate was provided so create a new self signed one.
            (_dtlsCertificate, _dtlsPrivateKey) = DtlsUtils.CreateSelfSignedTlsCert(_crypto, useRsa: configuration?.X_UseRsaForDtlsCertificate ?? false);
        }

        DtlsCertificateFingerprint = DtlsUtils.Fingerprint(_dtlsCertificate);

        SessionID = Guid.NewGuid().ToString();
        LocalSdpSessionID = Crypto.GetRandomInt(5).ToString();

        // Request the underlying RTP session to create a single RTP channel that will
        // be used to multiplex all required media streams.
        addSingleTrack(videoAsPrimary);

        _rtpIceChannel = GetRtpChannel();

        _rtpIceChannel.OnIceCandidate += (candidate) => _onIceCandidate?.Invoke(candidate);
        _rtpIceChannel.OnIceConnectionStateChange += IceConnectionStateChange;
        _rtpIceChannel.OnIceGatheringStateChange += (state) => onicegatheringstatechange?.Invoke(state);
        _rtpIceChannel.OnIceGatheringStateChange += (state) =>
        {
            if (state == RTCIceGatheringState.complete) { _iceCompletedGatheringTask.TrySetResult(true); }
        };
        _rtpIceChannel.OnIceCandidateError += (candidate, error) => onicecandidateerror?.Invoke(candidate, error);

        OnRtpClosed += Close;
        OnRtcpBye += Close;

        //Cancel Negotiation Task Event to Prevent Duplicated Calls
        onnegotiationneeded += CancelOnNegotiationNeededTask;

        sctp = new RTCSctpTransport(SCTP_DEFAULT_PORT, SCTP_DEFAULT_PORT, _rtpIceChannel.RTPPort);

        onnegotiationneeded?.Invoke();

        // This is the point the ICE session potentially starts contacting STUN and TURN servers.
        // This job was moved to a background thread as it was observed that interacting with the OS network
        // calls and/or initialising DNS was taking up to 600ms, see
        // https://github.com/sipsorcery-org/sipsorcery/issues/456.
        _iceInitiateGatheringTask = Task.Run(_rtpIceChannel.StartGathering);
    }

    private bool InitializeCertificates(RTCConfiguration configuration)
    {
        if (configuration.certificates2 is null || configuration.certificates2.Count == 0)
        {
            return false;
        }

        Debug.Assert(configuration is { });
        Debug.Assert(configuration.certificates2 is { Count: > 0 });
        Debug.Assert(configuration.certificates2[0]?.Certificate is { });
        Debug.Assert(configuration.certificates2[0]?.Certificate?.CertificateStructure is { });
        _dtlsCertificate = new Certificate(new[] { new BcTlsCertificate(_crypto, configuration.certificates2[0]?.Certificate?.CertificateStructure) });
        _dtlsPrivateKey = configuration.certificates2[0].PrivateKey;

        return true;
    }

    /// <summary>
    /// Event handler for ICE connection state changes.
    /// </summary>
    /// <param name="iceState">The new ICE connection state.</param>
    private async void IceConnectionStateChange(RTCIceConnectionState iceState)
    {
        oniceconnectionstatechange?.Invoke(iceConnectionState);

        if (iceState == RTCIceConnectionState.connected && _rtpIceChannel.NominatedEntry is { })
        {
            if (_dtlsHandle is { })
            {
                var destinationEndPoint = _rtpIceChannel.NominatedEntry.RemoteCandidate.DestinationEndPoint;
                Debug.Assert(destinationEndPoint is { });
                if (base.PrimaryStream.DestinationEndPoint?.Address.Equals(destinationEndPoint.Address) == false ||
                    base.PrimaryStream.DestinationEndPoint?.Port != destinationEndPoint.Port)
                {
                    // Already connected and this event is due to change in the nominated remote candidate.
                    var connectedEP = destinationEndPoint;

                    SetGlobalDestination(connectedEP, connectedEP);
                    logger.LogWebRtcIceRemoteEndpointChange(connectedEP);
                }

                if (connectionState is RTCPeerConnectionState.disconnected or
                    RTCPeerConnectionState.failed)
                {
                    // The ICE connection state change is due to a re-connection.
                    connectionState = RTCPeerConnectionState.connected;
                    onconnectionstatechange?.Invoke(connectionState);
                }
            }
            else
            {
                connectionState = RTCPeerConnectionState.connecting;
                onconnectionstatechange?.Invoke(connectionState);

                var connectedEP = _rtpIceChannel.NominatedEntry.RemoteCandidate.DestinationEndPoint;
                Debug.Assert(connectedEP is { });

                SetGlobalDestination(connectedEP, connectedEP);
                logger.LogWebRtcIceConnected(connectedEP);

                var disableDtlsExtendedMasterSecret = _configuration is { X_DisableExtendedMasterSecretKey: true };

                Debug.Assert(_dtlsPrivateKey is { });

                _dtlsHandle = new DtlsSrtpTransport(
                    IceRole == IceRolesEnum.active
                        ? new DtlsSrtpClient(_crypto, _dtlsCertificate, _dtlsPrivateKey, _configuration.X_UseRsaForDtlsCertificate ? SignatureAlgorithm.rsa : SignatureAlgorithm.ecdsa)
                        {
                            ForceUseExtendedMasterSecret = !disableDtlsExtendedMasterSecret
                        }
                        : new DtlsSrtpServer(_crypto, _dtlsCertificate, _dtlsPrivateKey, _configuration.X_UseRsaForDtlsCertificate ? SignatureAlgorithm.rsa : SignatureAlgorithm.ecdsa)
                        {
                            ForceUseExtendedMasterSecret = !disableDtlsExtendedMasterSecret,
                            ForceDisableMKI = true
                        }
                );

                _dtlsHandle.OnAlert += OnDtlsAlert;

                logger.LogWebRtcDtlsHandshakeStarted(IceRole);

                try
                {
                    var handshakeResult = await Task.Run(() => DoDtlsHandshake(_dtlsHandle)).ConfigureAwait(false);

                    connectionState = handshakeResult ? RTCPeerConnectionState.connected : connectionState = RTCPeerConnectionState.failed;
                    onconnectionstatechange?.Invoke(connectionState);

                    if (connectionState == RTCPeerConnectionState.connected)
                    {
                        await base.Start().ConfigureAwait(false);
                        await InitialiseSctpTransport().ConfigureAwait(false);
                    }
                }
                catch (Exception excp)
                {
                    logger.LogWebRtcDtlsHandshakeError(excp.Message, excp);

                    //connectionState = RTCPeerConnectionState.failed;
                    //onconnectionstatechange?.Invoke(connectionState);

                    Close("dtls handshake failed");
                }
            }
        }

        if (iceConnectionState == RTCIceConnectionState.checking)
        {
            // Not sure about this correspondence between the ICE and peer connection states.
            // TODO: Double check spec.
            //connectionState = RTCPeerConnectionState.connecting;
            //onconnectionstatechange?.Invoke(connectionState);
        }
        else if (iceConnectionState == RTCIceConnectionState.disconnected)
        {
            if (connectionState == RTCPeerConnectionState.connected)
            {
                connectionState = RTCPeerConnectionState.disconnected;
                onconnectionstatechange?.Invoke(connectionState);
            }
            else
            {
                connectionState = RTCPeerConnectionState.failed;
                onconnectionstatechange?.Invoke(connectionState);
            }
        }
        else if (iceConnectionState == RTCIceConnectionState.failed)
        {
            connectionState = RTCPeerConnectionState.failed;
            onconnectionstatechange?.Invoke(connectionState);
        }
    }

    /// <summary>
    /// Creates a new RTP ICE channel (which manages the UDP socket sending and receiving RTP
    /// packets) for use with this session.
    /// </summary>
    /// <returns>A new RTPChannel instance.</returns>
    protected override RTPChannel CreateRtpChannel()
    {
        if (rtpSessionConfig.IsMediaMultiplexed)
        {
            if (MultiplexRtpChannel is { })
            {
                return MultiplexRtpChannel;
            }
        }

        var rtpIceChannel = new RtpIceChannel(
            _configuration?.X_BindAddress,
            RTCIceComponent.rtp,
            _configuration?.iceServers,
            _configuration is { } ? _configuration.iceTransportPolicy : RTCIceTransportPolicy.all,
            _configuration is { } ? _configuration.X_ICEIncludeAllInterfaceAddresses : false,
            rtpSessionConfig.BindPort == 0 ? 0 : rtpSessionConfig.BindPort + m_rtpChannelsCount * 2,
            rtpSessionConfig.RtpPortRange);

        if (rtpSessionConfig.IsMediaMultiplexed)
        {
            MultiplexRtpChannel = rtpIceChannel;
        }

        rtpIceChannel.OnRTPDataReceived += OnRTPDataReceived;

        // Start the RTP, and if required the Control, socket receivers and the RTCP session.
        rtpIceChannel.Start();

        m_rtpChannelsCount++;

        return rtpIceChannel;
    }

    /// <summary>
    /// Sets the local SDP.
    /// </summary>
    /// <remarks>
    /// As specified in https://www.w3.org/TR/webrtc/#dom-peerconnection-setlocaldescription.
    /// </remarks>
    /// <param name="init">Optional. The session description to set as 
    /// local description. If not supplied then an offer or answer will be created as required.
    /// </param>
    public Task setLocalDescription(RTCSessionDescriptionInit init)
    {
        localDescription = new RTCSessionDescription { type = init.type, sdp = SDP.ParseSDPDescription(init.sdp.AsSpan()) };

        if (init.type == RTCSdpType.offer)
        {
            _rtpIceChannel.IsController = true;
        }

        if (signalingState == RTCSignalingState.have_remote_offer)
        {
            signalingState = RTCSignalingState.stable;
            onsignalingstatechange?.Invoke();
        }
        else
        {
            signalingState = RTCSignalingState.have_local_offer;
            onsignalingstatechange?.Invoke();
        }

        return Task.CompletedTask;
    }

    /// <summary>
    /// This set remote description overload is a convenience method for SIP/VoIP callers
    /// instead of WebRTC callers. The method signature better matches what the SIP
    /// user agent is expecting.
    /// TODO: Using two very similar overloads could cause confusion. Possibly
    /// consolidate.
    /// </summary>
    /// <param name="sdpType">Whether the remote SDP is an offer or answer.</param>
    /// <param name="sessionDescription">The SDP from the remote party.</param>
    /// <returns>The result of attempting to set the remote description.</returns>
    public override SetDescriptionResultEnum SetRemoteDescription(SdpType sdpType, SDP sessionDescription)
    {
        var init = new RTCSessionDescriptionInit
        {
            sdp = sessionDescription.ToString(),
            type = (sdpType == SdpType.answer) ? RTCSdpType.answer : RTCSdpType.offer
        };

        return setRemoteDescription(init);
    }

    /// <summary>
    /// Updates the session after receiving the remote SDP.
    /// </summary>
    /// <param name="init">The answer/offer SDP from the remote party.</param>
    public SetDescriptionResultEnum setRemoteDescription(RTCSessionDescriptionInit init)
    {
        remoteDescription = new RTCSessionDescription { type = init.type, sdp = SDP.ParseSDPDescription(init.sdp.AsSpan()) };

        var remoteSdp = remoteDescription.sdp; // SDP.ParseSDPDescription(init.sdp);
        Debug.Assert(remoteSdp is { });

        // Need to store uri/id of know extensions
        _rtpExtensionsUsed ??= new Dictionary<string, int>();
        foreach (var ann in remoteSdp.Media)
        {
            if (ann.Media is SDPMediaTypesEnum.audio or SDPMediaTypesEnum.video)
            {
                var extensions = ann.HeaderExtensions?.Values;
                if (extensions is { })
                {
                    foreach (var extension in extensions)
                    {
                        logger.LogWebRtcRemoteDescription(extension.Id, extension.Uri);
                        _rtpExtensionsUsed[extension.Uri] = extension.Id;
                    }
                }
            }
        }

        var sdpType = (init.type == RTCSdpType.offer) ? SdpType.offer : SdpType.answer;

        switch (signalingState)
        {
            case var sigState when sigState == RTCSignalingState.have_local_offer && sdpType == SdpType.offer:
                logger.LogWebRtcSignalingStateRejectOffer(sigState);
                return SetDescriptionResultEnum.WrongSdpTypeOfferAfterOffer;
        }

        var setResult = base.SetRemoteDescription(sdpType, remoteSdp);

        if (setResult == SetDescriptionResultEnum.OK)
        {
            var remoteIceUser = remoteSdp.IceUfrag;
            var remoteIcePassword = remoteSdp.IcePwd;
            var dtlsFingerprint = remoteSdp.DtlsFingerprint;
            var remoteIceRole = remoteSdp.IceRole;

            foreach (var ann in remoteSdp.Media)
            {
                if (remoteIceUser is null || remoteIcePassword is null || dtlsFingerprint is null || remoteIceRole is null)
                {
                    remoteIceUser = remoteIceUser ?? ann.IceUfrag;
                    remoteIcePassword = remoteIcePassword ?? ann.IcePwd;
                    dtlsFingerprint = dtlsFingerprint ?? ann.DtlsFingerprint;
                    remoteIceRole = remoteIceRole ?? ann.IceRole;
                }

                // Check for data channel announcements.
                if (HasSdpDataChannelFormat(ann))
                {
                    if (ann.Transport is RTP_MEDIA_DATACHANNEL_DTLS_PROFILE or
                        RTP_MEDIA_DATACHANNEL_UDPDTLS_PROFILE)
                    {
                        dtlsFingerprint = dtlsFingerprint ?? ann.DtlsFingerprint;
                        remoteIceRole = remoteIceRole ?? remoteSdp.IceRole;
                    }
                    else
                    {
                        logger.LogWebRtcDataTransportUnsupported(ann.Transport);
                        return SetDescriptionResultEnum.DataChannelTransportNotSupported;
                    }
                }

                static bool HasSdpDataChannelFormat(SDPMediaAnnouncement ann)
                {
                    if (ann.Media == SDPMediaTypesEnum.application)
                    {
                        return false;
                    }
                    foreach (var kv in ann.ApplicationMediaFormats)
                    {
                        return kv.Key == SDP_DATACHANNEL_FORMAT_ID;
                    }

                    return false;
                }
            }

            SdpSessionID = remoteSdp.SessionId;

            if (remoteSdp.IceImplementation == IceImplementationEnum.lite)
            {
                _rtpIceChannel.IsController = true;
            }
            if (init.type == RTCSdpType.answer)
            {
                _rtpIceChannel.IsController = true;
                IceRole = remoteIceRole == IceRolesEnum.passive ? IceRolesEnum.active : IceRolesEnum.passive;
            }
            //As Chrome does not support changing IceRole while renegotiating we need to keep same previous IceRole if we already negotiated before
            else
            {
                // Set DTLS role as client.
                IceRole = IceRolesEnum.active;
            }

            if (remoteIceUser is { } && remoteIcePassword is { })
            {
                _rtpIceChannel.SetRemoteCredentials(remoteIceUser, remoteIcePassword);
            }

            if (!string.IsNullOrWhiteSpace(dtlsFingerprint))
            {
                dtlsFingerprint = dtlsFingerprint.Trim().ToLower();
                if (RTCDtlsFingerprint.TryParse(dtlsFingerprint, out var remoteFingerprint))
                {
                    RemotePeerDtlsFingerprint = remoteFingerprint;
                }
                else
                {
                    logger.LogWebRtcDtlsFingerprintInvalid();
                    return SetDescriptionResultEnum.DtlsFingerprintDigestNotSupported;
                }
            }
            else
            {
                logger.LogWebRtcDtlsFingerprintMissing();
                return SetDescriptionResultEnum.DtlsFingerprintMissing;
            }

            // All browsers seem to have gone to trickling ICE candidates now but just
            // in case one or more are given we can start the STUN dance immediately.
            if (remoteSdp.IceCandidates is { })
            {
                foreach (var iceCandidate in remoteSdp.IceCandidates)
                {
                    addIceCandidate(new RTCIceCandidateInit { candidate = iceCandidate.ToString() });
                }
            }

            ResetRemoteSDPSsrcAttributes();
            foreach (var media in remoteSdp.Media)
            {
                if (media.IceCandidates is { })
                {
                    foreach (var iceCandidate in media.IceCandidates)
                    {
                        addIceCandidate(new RTCIceCandidateInit { candidate = iceCandidate.ToString() });
                    }
                }

                AddRemoteSDPSsrcAttributes(media.Media, media.SsrcAttributes);
            }

            logger.LogRtpSessionRemoteSdpSsrcAttributes(audioRemoteSDPSsrcAttributes, videoRemoteSDPSsrcAttributes, textRemoteSDPSsrcAttributes);

            UpdatedSctpDestinationPort();

            if (init.type == RTCSdpType.offer)
            {
                signalingState = RTCSignalingState.have_remote_offer;
                onsignalingstatechange?.Invoke();
            }
            else
            {
                signalingState = RTCSignalingState.stable;
                onsignalingstatechange?.Invoke();
            }

            // Trigger the ICE candidate events for any non-host candidates, host candidates are always included in the
            // SDP offer/answer. The reason for the trigger is that ICE candidates cannot be sent to the remote peer
            // until it is ready to receive them which is indicated by the remote offer being received.
            foreach (var nonHostCand in _rtpIceChannel.Candidates)
            {
                if (nonHostCand.type != RTCIceCandidateType.host)
                {
                    _onIceCandidate?.Invoke(nonHostCand);
                }
            }
        }

        return setResult;
    }

    /// <summary>
    /// Close the session including the underlying RTP session and channels.
    /// </summary>
    /// <param name="reason">An optional descriptive reason for the closure.</param>
    public override void Close(string? reason)
    {
        if (!IsClosed)
        {
            logger.LogWebRtcPeerConnectionClose(reason ?? "<none>");

            // Close all DataChannels
            if (DataChannels?.Count > 0)
            {
                foreach (var dc in DataChannels)
                {
                    dc?.close();
                }
            }

            _rtpIceChannel?.Close();
            _dtlsHandle?.Close();

            sctp?.Close();

            base.Close(reason); // Here Audio and/or Video Streams are closed

            connectionState = RTCPeerConnectionState.closed;
            onconnectionstatechange?.Invoke(RTCPeerConnectionState.closed);
        }
    }

    /// <summary>
    /// Closes the connection with the default reason.
    /// </summary>
    public void close()
    {
        Close(NORMAL_CLOSE_REASON);
    }

    /// <summary>
    /// Generates the SDP for an offer that can be made to a remote peer.
    /// </summary>
    /// <remarks>
    /// As specified in https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-createoffer.
    /// </remarks>
    /// <param name="options">Optional. If supplied the options will be sued to apply additional
    /// controls over the generated offer SDP.</param>
    public RTCSessionDescriptionInit createOffer(RTCOfferOptions? options = null)
    {
        var mediaStreamList = GetMediaStreams();
        //Revert to DefaultStreamStatus
        foreach (var mediaStream in mediaStreamList)
        {
            if (mediaStream.LocalTrack is { } && mediaStream.LocalTrack.StreamStatus == MediaStreamStatusEnum.Inactive)
            {
                mediaStream.LocalTrack.StreamStatus = mediaStream.LocalTrack.DefaultStreamStatus;
            }
        }

        var excludeIceCandidates = options is { } && options.X_ExcludeIceCandidates;
        var waitForIceGatheringToComplete = options is { } && options.X_WaitForIceGatheringToComplete;

        var offerSdp = createBaseSdp(mediaStreamList, excludeIceCandidates, waitForIceGatheringToComplete);

        var indexAudioStream = 0;
        var indexVideoStream = 0;
        _rtpExtensionsUsed ??= new Dictionary<string, int>();
        foreach (var ann in offerSdp.Media)
        {
            // Audio - Add RTP Extension we want or can support
            if (ann.Media == SDPMediaTypesEnum.audio)
            {
                ann.HeaderExtensions.Clear();

                var localHeaderExtensions = AudioStreamList[indexAudioStream].LocalTrack?.HeaderExtensions?.Values;
                if (localHeaderExtensions is { })
                {
                    foreach (var localExtension in localHeaderExtensions)
                    {
                        // We must ensure to use same Id by extension
                        if (_rtpExtensionsUsed.TryGetValue(localExtension.Uri, out var rtpExtensionsUsedValue))
                        {
                            localExtension.Id = rtpExtensionsUsedValue;
                        }
                        else
                        {
                            _rtpExtensionsUsed[localExtension.Uri] = localExtension.Id;
                        }

                        logger.LogWebRtcCreateOfferHeaderExtension(ann.Media, ann.MediaID, localExtension.Id, localExtension.Uri);
                        ann.HeaderExtensions[localExtension.Id] = localExtension;
                    }
                }
                indexAudioStream++;
            }
            // Video - Add RTP Extension we want or can support
            else if (ann.Media == SDPMediaTypesEnum.video)
            {
                ann.HeaderExtensions.Clear();

                var localHeaderExtensions = VideoStreamList[indexVideoStream].LocalTrack?.HeaderExtensions?.Values;
                if (localHeaderExtensions is { })
                {
                    foreach (var localExtension in localHeaderExtensions)
                    {
                        // We must ensure to use same Id by extension
                        if (_rtpExtensionsUsed.TryGetValue(localExtension.Uri, out var value))
                        {
                            localExtension.Id = value;
                        }
                        else
                        {
                            _rtpExtensionsUsed[localExtension.Uri] = localExtension.Id;
                        }

                        logger.LogWebRtcCreateOfferHeaderExtension(ann.Media, ann.MediaID, localExtension.Id, localExtension.Uri);
                        ann.HeaderExtensions[localExtension.Id] = localExtension;
                    }
                }
                indexVideoStream++;
            }
            ann.IceRole = IceRole;
        }

        var initDescription = new RTCSessionDescriptionInit
        {
            type = RTCSdpType.offer,
            sdp = offerSdp.ToString()
        };

        return initDescription;
    }

    /// <summary>
    /// Convenience overload to suit SIP/VoIP callers.
    /// TODO: Consolidate with createAnswer.
    /// </summary>
    /// <param name="connectionAddress">Not used.</param>
    /// <returns>An SDP payload to answer an offer from the remote party.</returns>
    public override SDP? CreateOffer(IPAddress connectionAddress)
    {
        var result = createOffer(null);

        if (result?.sdp is { })
        {
            return SDP.ParseSDPDescription(result.sdp.AsSpan());
        }

        return null;
    }

    /// <summary>
    /// Convenience overload to suit SIP/VoIP callers.
    /// TODO: Consolidate with createAnswer.
    /// </summary>
    /// <param name="connectionAddress">Not used.</param>
    /// <returns>An SDP payload to answer an offer from the remote party.</returns>
    public override SDP? CreateAnswer(IPAddress? connectionAddress)
    {
        var result = createAnswer(null);

        if (result?.sdp is { })
        {
            return SDP.ParseSDPDescription(result.sdp.AsSpan());
        }

        return null;
    }

    /// <summary>
    /// Creates an answer to an SDP offer from a remote peer.
    /// </summary>
    /// <remarks>
    /// As specified in https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-createanswer and
    /// https://tools.ietf.org/html/rfc3264#section-6.1.
    /// </remarks>
    /// <param name="options">Optional. If supplied the options will be used to apply additional
    /// controls over the generated answer SDP.</param>
    public RTCSessionDescriptionInit createAnswer(RTCAnswerOptions? options = null)
    {
        if (remoteDescription is null)
        {
            throw new SipSorceryException("The remote SDP must be set before an SDP answer can be created.");
        }
        else
        {
            var mediaStreamList = GetMediaStreams();
            //Revert to DefaultStreamStatus
            foreach (var mediaStream in mediaStreamList)
            {
                if (mediaStream.LocalTrack is { } && mediaStream.LocalTrack.StreamStatus == MediaStreamStatusEnum.Inactive)
                {
                    mediaStream.LocalTrack.StreamStatus = mediaStream.LocalTrack.DefaultStreamStatus;
                }
            }

            var excludeIceCandidates = options is { } && options.X_ExcludeIceCandidates;
            var answerSdp = createBaseSdp(mediaStreamList, excludeIceCandidates);

            var indexAudioStream = 0;
            var indexVideoStream = 0;
            _rtpExtensionsUsed ??= new Dictionary<string, int>();
            foreach (var ann in answerSdp.Media)
            {
                // Audio - RTP Extension must be same on Local and Remote Track
                if (ann.Media == SDPMediaTypesEnum.audio)
                {
                    ann.HeaderExtensions.Clear();

                    var localHeaderExtensions = AudioStreamList[indexAudioStream].LocalTrack?.HeaderExtensions;
                    var remoteHeaderExtensions = AudioStreamList[indexAudioStream].RemoteTrack?.HeaderExtensions?.Values;
                    if ((remoteHeaderExtensions is { Count: > 0 }) && (localHeaderExtensions is { Count: > 0 }))
                    {
                        foreach (var remoteExtension in remoteHeaderExtensions)
                        {
                            var localExtension = FindLocalExtensionByUri(localHeaderExtensions, remoteExtension.Uri);
                            if ((localExtension is { }) && _rtpExtensionsUsed.TryGetValue(remoteExtension.Uri, out var value))
                            {
                                // We must ensure to use same Id by extension
                                localExtension.Id = value;

                                logger.LogWebRtcCreateAnswerHeaderExtension(ann.Media, ann.MediaID, localExtension.Id, localExtension.Uri);
                                ann.HeaderExtensions.Add(localExtension.Id, localExtension);
                            }
                        }
                    }
                    indexAudioStream++;
                }
                // Video - RTP Extension must be same on Local and Remote Track
                else if (ann.Media == SDPMediaTypesEnum.video)
                {
                    ann.HeaderExtensions.Clear();

                    var localHeaderExtensions = VideoStreamList[indexVideoStream].LocalTrack?.HeaderExtensions;
                    var remoteHeaderExtensions = VideoStreamList[indexVideoStream].RemoteTrack?.HeaderExtensions?.Values;
                    if ((remoteHeaderExtensions is { Count: > 0 }) && (localHeaderExtensions is { Count: > 0 }))
                    {
                        foreach (var remoteExtension in remoteHeaderExtensions)
                        {
                            var localExtension = FindLocalExtensionByUri(localHeaderExtensions, remoteExtension.Uri);
                            if ((localExtension is { }) && _rtpExtensionsUsed.TryGetValue(remoteExtension.Uri, out var value))
                            {
                                // We must ensure to use same Id by extension
                                localExtension.Id = value;

                                logger.LogWebRtcCreateAnswerHeaderExtension(ann.Media, ann.MediaID, localExtension.Id, localExtension.Uri);
                                ann.HeaderExtensions.Add(localExtension.Id, localExtension);
                            }
                        }
                    }
                    indexVideoStream++;
                }

                static RTPHeaderExtension? FindLocalExtensionByUri(Dictionary<int, RTPHeaderExtension>? localHeaderExtensions, string uri)
                {
                    if (localHeaderExtensions is null)
                    {
                        return null;
                    }

                    foreach (var (_, le) in localHeaderExtensions)
                    {
                        if (le.Uri == uri)
                        {
                            return le;
                        }
                    }

                    return null;
                }
            }

            //if (answerSdp.Media.Any(x => x.Media == SDPMediaTypesEnum.audio))
            //{
            //    var audioAnnouncement = answerSdp.Media.Where(x => x.Media == SDPMediaTypesEnum.audio).Single();
            //    audioAnnouncement.IceRole = IceRole;
            //}

            //if (answerSdp.Media.Any(x => x.Media == SDPMediaTypesEnum.video))
            //{
            //    var videoAnnouncement = answerSdp.Media.Where(x => x.Media == SDPMediaTypesEnum.video).Single();
            //    videoAnnouncement.IceRole = IceRole;
            //}

            var initDescription = new RTCSessionDescriptionInit
            {
                type = RTCSdpType.answer,
                sdp = answerSdp.ToString()
            };

            return initDescription;
        }
    }

    /// <summary>
    /// For standard use this method should not need to be called. The remote peer's ICE
    /// user and password will be set when from the SDP. This method is provided for 
    /// diagnostics purposes.
    /// </summary>
    /// <param name="remoteIceUser">The remote peer's ICE user value.</param>
    /// <param name="remoteIcePassword">The remote peer's ICE password value.</param>
    public void SetRemoteCredentials(string remoteIceUser, string remoteIcePassword)
    {
        _rtpIceChannel.SetRemoteCredentials(remoteIceUser, remoteIcePassword);
    }

    /// <summary>
    /// Gets the RTP channel being used to send and receive data on this peer connection.
    /// Unlike the base RTP session peer connections only ever use a single RTP channel.
    /// Audio and video (and RTCP) are all multiplexed on the same channel.
    /// </summary>
    public RtpIceChannel GetRtpChannel()
    {
        var rtpIceChannel = PrimaryStream.GetRTPChannel() as RtpIceChannel;
        Debug.Assert(rtpIceChannel is { });
        return rtpIceChannel;
    }

    /// <summary>
    /// Generates the base SDP for an offer or answer. The SDP will then be tailored depending
    /// on whether it's being used in an offer or an answer.
    /// </summary>
    /// <param name="mediaStreamList">THe media streamss to add to the SDP description.</param>
    /// <param name="excludeIceCandidates">If true it indicates the caller does not want ICE candidates added
    /// to the SDP.</param>
    /// <param name="waitForIceGatheringToComplete">If set to true the SDP generation will wait until the ICE gathering is complete
    /// before generating the SDP. This is a convenient way to get ICE candidates to be included in the SDP.</param>
    /// <remarks>
    /// From https://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-sdp-39#section-4.2.5:
    ///   "The transport address from the peer for the default destination
    ///   is set to IPv4/IPv6 address values "0.0.0.0"/"::" and port value
    ///   of "9".  This MUST NOT be considered as a ICE failure by the peer
    ///   agent and the ICE processing MUST continue as usual."
    /// </remarks>
    private SDP createBaseSdp(List<MediaStream> mediaStreamList, bool excludeIceCandidates = false, bool waitForIceGatheringToComplete = false)
    {
        // Make sure the ICE gathering of local IP addresses is complete.
        // This task should complete very quickly (<1s) but it is deemed very useful to wait
        // for it to complete as it allows local ICE candidates to be included in the SDP.
        // In theory it would be better to an async/await but that would result in a breaking
        // change to the API and for a one off (once per class instance not once per method call)
        // delay of a few hundred milliseconds it was decided not to break the API.
        using (var ct = new CancellationTokenSource(TimeSpan.FromMilliseconds(_configuration.X_GatherTimeoutMs)))
        {
            try
            {
                _iceInitiateGatheringTask.Wait(ct.Token);
            }
            catch (OperationCanceledException)
            {
                logger.LogWebRtcGatheringTimeout(_configuration.X_GatherTimeoutMs);
            }
        }

        if (waitForIceGatheringToComplete)
        {
            using (var ct = new CancellationTokenSource(TimeSpan.FromMilliseconds(_configuration.X_GatherTimeoutMs)))
            {
                try
                {
                    _iceCompletedGatheringTask.Task.Wait();
                }
                catch (OperationCanceledException)
                {
                    logger.LogWebRtcGatheringCompleteTimeout(_configuration.X_GatherTimeoutMs);
                }
            }
        }

        var offerSdp = new SDP(IPAddress.Loopback);
        offerSdp.SessionId = LocalSdpSessionID;

        var dtlsFingerprint = this.DtlsCertificateFingerprint.ToString();
        var iceCandidatesAdded = false;

        // Media announcements must be in the same order in the offer and answer.
        var mediaIndex = 0;
        var audioMediaIndex = 0;
        var videoMediaIndex = 0;
        foreach (var mediaStream in mediaStreamList)
        {
            Debug.Assert(mediaStream.LocalTrack is { });

            var mindex = 0;
            var midTag = "0";

            if (RemoteDescription is null)
            {
                mindex = mediaIndex;
                midTag = mediaIndex.ToString();
            }
            else
            {
                if (mediaStream.LocalTrack.Kind == SDPMediaTypesEnum.audio)
                {
                    (mindex, midTag) = RemoteDescription.GetIndexForMediaType(mediaStream.LocalTrack.Kind, audioMediaIndex);
                    audioMediaIndex++;
                }
                else if (mediaStream.LocalTrack.Kind == SDPMediaTypesEnum.video)
                {
                    (mindex, midTag) = RemoteDescription.GetIndexForMediaType(mediaStream.LocalTrack.Kind, videoMediaIndex);
                    videoMediaIndex++;
                }
            }
            mediaIndex++;

            if (mindex == SDP.MEDIA_INDEX_NOT_PRESENT)
            {
                logger.LogWebRtcCheckpointExcluded(mediaStream.LocalTrack.Kind);
            }
            else
            {
                var announcement = new SDPMediaAnnouncement(
                 mediaStream.LocalTrack.Kind,
                 SDP.IGNORE_RTP_PORT_NUMBER,
                 mediaStream.LocalTrack.Capabilities);

                announcement.Transport = RTP_MEDIA_PROFILE;
                announcement.Connection = new SDPConnectionInformation(IPAddress.Any);
                announcement.AddExtra(RTCP_MUX_ATTRIBUTE);
                announcement.AddExtra(RTCP_ATTRIBUTE);
                announcement.MediaStreamStatus = mediaStream.LocalTrack.StreamStatus;
                announcement.MediaID = midTag;
                announcement.MLineIndex = mindex;

                announcement.IceUfrag = _rtpIceChannel.LocalIceUser;
                announcement.IcePwd = _rtpIceChannel.LocalIcePassword;
                announcement.IceOptions = ICE_OPTIONS;
                announcement.IceRole = IceRole;
                announcement.DtlsFingerprint = dtlsFingerprint;

                if (iceCandidatesAdded == false && !excludeIceCandidates)
                {
                    AddIceCandidates(announcement);
                    iceCandidatesAdded = true;
                }

                if (mediaStream.LocalTrack.Ssrc != 0)
                {
                    var trackCname = mediaStream.RtcpSession?.Cname;

                    if (trackCname is { })
                    {
                        announcement.SsrcAttributes.Add(new SDPSsrcAttribute(mediaStream.LocalTrack.Ssrc, trackCname, null));
                    }
                }

                offerSdp.Media.Add(announcement);
            }
        }

        if (DataChannels.Count > 0 || (RemoteDescription?.Media.Exists(static x => x.Media == SDPMediaTypesEnum.application) ?? false))
        {
            (var mindex, var midTag) = RemoteDescription is null ? (mediaIndex, mediaIndex.ToString()) : RemoteDescription.GetIndexForMediaType(SDPMediaTypesEnum.application, 0);
            mediaIndex++;

            if (mindex == SDP.MEDIA_INDEX_NOT_PRESENT)
            {
                logger.LogWebRtcMediaAnnouncementWarn();
            }
            else
            {
                var dataChannelAnnouncement = new SDPMediaAnnouncement(
                    SDPMediaTypesEnum.application,
                    SDP.IGNORE_RTP_PORT_NUMBER,
                    new List<SDPApplicationMediaFormat> { new SDPApplicationMediaFormat(SDP_DATACHANNEL_FORMAT_ID) });
                dataChannelAnnouncement.Transport = RTP_MEDIA_DATACHANNEL_UDPDTLS_PROFILE;
                dataChannelAnnouncement.Connection = new SDPConnectionInformation(IPAddress.Any);

                dataChannelAnnouncement.SctpPort = SCTP_DEFAULT_PORT;
                dataChannelAnnouncement.MaxMessageSize = sctp.maxMessageSize;
                dataChannelAnnouncement.MLineIndex = mindex;
                dataChannelAnnouncement.MediaID = midTag;
                dataChannelAnnouncement.IceUfrag = _rtpIceChannel.LocalIceUser;
                dataChannelAnnouncement.IcePwd = _rtpIceChannel.LocalIcePassword;
                dataChannelAnnouncement.IceOptions = ICE_OPTIONS;
                dataChannelAnnouncement.IceRole = IceRole;
                dataChannelAnnouncement.DtlsFingerprint = dtlsFingerprint;

                if (iceCandidatesAdded == false && !excludeIceCandidates)
                {
                    AddIceCandidates(dataChannelAnnouncement);
                    iceCandidatesAdded = true;
                }

                offerSdp.Media.Add(dataChannelAnnouncement);
            }
        }

        // Set the Bundle attribute to indicate all media announcements are being multiplexed.
        if (offerSdp.Media?.Count > 0)
        {
            offerSdp.Group = BUNDLE_ATTRIBUTE;
            // order by MLineIndex then MediaID without LINQ
            offerSdp.Media.Sort((a, b) =>
            {
                var cmp = a.MLineIndex.CompareTo(b.MLineIndex);
                return cmp != 0 ? cmp : string.Compare(a.MediaID, b.MediaID, StringComparison.Ordinal);
            });
            foreach (var ann in offerSdp.Media)
            {
                offerSdp.Group += $" {ann.MediaID}";
            }
        }

        return offerSdp;

        // Local function to add ICE candidates to one of the media announcements.
        void AddIceCandidates(SDPMediaAnnouncement announcement)
        {
            if (_rtpIceChannel.Candidates?.Count > 0)
            {
                announcement.IceCandidates = new List<RTCIceCandidate>();

                // Add ICE candidates.
                foreach (var iceCandidate in _rtpIceChannel.Candidates)
                {
                    announcement.IceCandidates.Add(iceCandidate);
                }

                foreach (var iceCandidate in _applicationIceCandidates)
                {
                    announcement.IceCandidates.Add(iceCandidate);
                }

                if (_rtpIceChannel.IceGatheringState == RTCIceGatheringState.complete)
                {
                    announcement.AddExtra($"a={SDP.END_ICE_CANDIDATES_ATTRIBUTE}");
                }
            }
        }
    }

    /// <summary>
    /// From RFC5764: <![CDATA[
    ///             +----------------+
    ///             | 127 < B< 192  -+--> forward to RTP
    ///             |                |
    /// packet -->  |  19 < B< 64   -+--> forward to DTLS
    ///             |                |
    ///             |       B< 2    -+--> forward to STUN
    ///             +----------------+
    /// ]]>
    /// </summary>
    /// <paramref name="localPort">The local port on the RTP socket that received the packet.</paramref>
    /// <param name="remoteEP">The remote end point the packet was received from.</param>
    /// <param name="buffer">The data received.</param>
    private void OnRTPDataReceived(int localPort, IPEndPoint remoteEP, ReadOnlyMemory<byte> buffer)
    {
        //logger.LogDebug($"RTP channel received a packet from {remoteEP}, {buffer?.Length} bytes.");

        // By this point the RTP ICE channel has already processed any STUN packets which means 
        // it's only necessary to separate RTP/RTCP from DTLS.
        // Because DTLS packets can be fragmented and RTP/RTCP should never be, use the RTP/RTCP 
        // prefix to distinguish.

        if (!buffer.IsEmpty)
        {
            try
            {
                if (buffer.Length > RTPHeader.MIN_HEADER_LEN && buffer.Span[0] >= 128 && buffer.Span[0] <= 191)
                {
                    // RTP/RTCP packet.
                    base.OnReceive(localPort, remoteEP, buffer);
                }
                else
                {
                    if (_dtlsHandle is { })
                    {
                        //logger.LogDebug($"DTLS transport received {buffer.Length} bytes from {AudioDestinationEndPoint}.");
                        //TODO: Optimize to avoid array Allocation
                        _dtlsHandle.WriteToRecvStream(buffer.ToArray());
                    }
                    else
                    {
                        logger.LogWebRtcDtlsRecvNoTransport(buffer.Length, remoteEP);
                    }
                }
            }
            catch (Exception excp)
            {
                logger.LogWebRtcRtpDataReceiveError(excp.Message, excp);
            }
        }
    }

    /// <summary>
    /// Used to add a local ICE candidate. These are for candidates that the application may
    /// want to provide in addition to the ones that will be automatically determined. An
    /// example is when a machine is behind a 1:1 NAT and the application wants a host 
    /// candidate with the public IP address to be included.
    /// </summary>
    /// <param name="candidate">The ICE candidate to add.</param>
    /// <example>
    /// var natCandidate = new RTCIceCandidate(RTCIceProtocol.udp, natAddress, natPort, RTCIceCandidateType.host);
    /// pc.addLocalIceCandidate(natCandidate);
    /// </example>
    public void addLocalIceCandidate(RTCIceCandidate candidate)
    {
        candidate.usernameFragment = _rtpIceChannel.LocalIceUser;
        _applicationIceCandidates.Add(candidate);
    }

    /// <summary>
    /// Used to add remote ICE candidates to the peer connection's checklist.
    /// </summary>
    /// <param name="candidateInit">The remote ICE candidate to add.</param>
    public void addIceCandidate(RTCIceCandidateInit candidateInit)
    {
        var candidate = new RTCIceCandidate(candidateInit);

        if (_rtpIceChannel.Component == candidate.component)
        {
            _rtpIceChannel.AddRemoteCandidate(candidate);
        }
        else
        {
            logger.LogWebRtcIceSessionError(candidate.component);
        }
    }

    /// <summary>
    /// Restarts the ICE session gathering and connection checks.
    /// </summary>
    public void restartIce()
    {
        _rtpIceChannel.Restart();
    }

    /// <summary>
    /// Gets the initial optional configuration settings this peer connection was created
    /// with.
    /// </summary>
    /// <returns>If available the initial configuration options.</returns>
    public RTCConfiguration getConfiguration()
    {
        return _configuration;
    }

    /// <summary>
    /// Not implemented. Configuration options cannot currently be changed once the peer
    /// connection has been initialised.
    /// </summary>
    public void setConfiguration(RTCConfiguration? configuration = null)
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// Once the SDP exchange has been made the SCTP transport ports are known. If the destination
    /// port is not using the default value attempt to update it on teh SCTP transprot.
    /// </summary>
    private void UpdatedSctpDestinationPort()
    {
        Debug.Assert(RemoteDescription is { });

        // If a data channel was requested by the application then create the SCTP association.
        foreach (var ann in RemoteDescription.Media)
        {
            if (ann.Media == SDPMediaTypesEnum.application)
            {
                if (ann.SctpPort is { } sctpPort && sctpPort != SCTP_DEFAULT_PORT)
                {
                    sctp.UpdateDestinationPort(sctpPort);
                }

                return;
            }
        }
    }

    /// <summary>
    /// These internal function is used to call Renegotiation Event with delay as the user should call addTrack/removeTrack in sequence so we need a small delay to prevent multiple renegotiation calls
    /// </summary>
    /// <returns>Current Executing Task</returns>
    protected virtual Task StartOnNegotiationNeededTask()
    {
        const int RENEGOTIATION_CALL_DELAY = 100;

        //We need to reset the timer every time that we call this function
        CancelOnNegotiationNeededTask();

        CancellationToken token;
        lock (_renegotiationLock)
        {
            _cancellationSource = new CancellationTokenSource();
            token = _cancellationSource.Token;
        }
        return Task.Run(async () =>
        {
            //Call Renegotiation Delayed
            await Task.Delay(RENEGOTIATION_CALL_DELAY, token).ConfigureAwait(false);

            //Prevent continue with cancellation requested
            if (token.IsCancellationRequested)
            {
                return;
            }
            else
            {
                if (_requireRenegotiation)
                {
                    //We Already Subscribe CancelRenegotiationEventTask in Constructor so we dont need to handle with this function again here
                    onnegotiationneeded?.Invoke();
                }
            }
        }, token);
    }

    /// <summary>
    /// Cancel current Negotiation Event Call to prevent running thread to call OnNegotiationNeeded
    /// </summary>
    protected virtual void CancelOnNegotiationNeededTask()
    {
        lock (_renegotiationLock)
        {
            if (_cancellationSource is { })
            {
                if (!_cancellationSource.IsCancellationRequested)
                {
                    _cancellationSource.Cancel();
                }

                _cancellationSource = null;
            }
        }
    }

    /// <summary>
    /// Initialises the SCTP transport. This will result in the DTLS SCTP transport listening 
    /// for incoming INIT packets if the remote peer attempts to create the association. The local
    /// peer will NOT attempt to establish the association at this point. It's up to the
    /// application to specify it wants a data channel to initiate the SCTP association attempt.
    /// </summary>
    private async Task InitialiseSctpTransport()
    {
        try
        {
            sctp.OnStateChanged += OnSctpTransportStateChanged;
            Debug.Assert(_dtlsHandle is { });
            Debug.Assert(_dtlsHandle.Transport is { });
            sctp.Start(_dtlsHandle.Transport, _dtlsHandle.IsClient);

            if (DataChannels.Count > 0)
            {
                await InitialiseSctpAssociation().ConfigureAwait(false);
            }
        }
        catch (Exception excp)
        {
            logger.LogWebRtcSctpEstablishError(excp.Message, excp);
            sctp?.Close();
        }
    }

    /// <summary>
    /// Event handler for changes to the SCTP transport state.
    /// </summary>
    /// <param name="state">The new transport state.</param>
    private void OnSctpTransportStateChanged(RTCSctpTransportState state)
    {
        if (state == RTCSctpTransportState.Connected)
        {
            logger.LogWebRtcSctpTransportConnected();

            sctp.RTCSctpAssociation.OnDataChannelData += OnSctpAssociationDataChunk;
            sctp.RTCSctpAssociation.OnDataChannelOpened += OnSctpAssociationDataChannelOpened;
            sctp.RTCSctpAssociation.OnNewDataChannel += OnSctpAssociationNewDataChannel;

            // Create new SCTP streams for any outstanding data channel requests.
            foreach (var dataChannel in _dataChannels.ActivatePendingChannels())
            {
                OpenDataChannel(dataChannel);
            }
        }
    }

    /// <summary>
    /// Event handler for a new data channel being opened by the remote peer.
    /// </summary>
    private void OnSctpAssociationNewDataChannel(ushort streamID, DataChannelTypes type, ushort priority, uint reliability, string label, string protocol)
    {
        logger.LogWebRtcNewDataChannel(streamID, type, priority, reliability, label, protocol);

        // TODO: Set reliability, priority etc. properties on the data channel.
        var dc = new RTCDataChannel(sctp)
        {
            id = streamID,
            label = label,
            IsOpened = true,
            readyState = RTCDataChannelState.open,
            protocol = protocol
        };

        dc.SendDcepAck();

        if (_dataChannels.AddActiveChannel(dc))
        {
            ondatachannel?.Invoke(dc);
        }
        else
        {
            // TODO: What's the correct behaviour here?? I guess use the newest one and remove the old one?
            logger.LogWebRtcDuplicateDataChannel(streamID);
        }
    }

    /// <summary>
    /// Event handler for the confirmation that a data channel opened by this peer has been acknowledged.
    /// </summary>
    /// <param name="streamID">The ID of the stream corresponding to the acknowledged data channel.</param>
    private void OnSctpAssociationDataChannelOpened(ushort streamID)
    {
        _dataChannels.TryGetChannel(streamID, out var dc);

        var label = dc is { } ? dc.label : "<none>";
        Debug.Assert(label is { });
        logger.LogWebRtcDataChannelOpened(label, streamID);

        if (dc is { })
        {
            dc.GotAck();
        }
        else
        {
            logger.LogWebRtcDataChannelIdError(streamID);
        }
    }

    /// <summary>
    /// Event handler for an SCTP DATA chunk being received on the SCTP association.
    /// </summary>
    private void OnSctpAssociationDataChunk(SctpDataFrame frame)
    {
        if (_dataChannels.TryGetChannel(frame.StreamID, out var dc))
        {
            Debug.Assert(dc is { });
            Debug.Assert(frame.UserData is { });
            dc.GotData(frame.StreamID, frame.StreamSeqNum, frame.PPID, frame.UserData);
        }
        else
        {
            logger.LogWebRtcDataChannelForStreamId(frame.StreamID);
        }
    }

    /// <summary>
    /// When a data channel is requested an SCTP association is needed. This method attempts to 
    /// initialise the association if it is not already available.
    /// </summary>
    private async Task InitialiseSctpAssociation()
    {
        if (sctp.RTCSctpAssociation.State != SctpAssociationState.Established)
        {
            sctp.Associate();
        }

        if (sctp.state != RTCSctpTransportState.Connected)
        {
            var onSctpConnectedTcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);
            sctp.OnStateChanged += (state) =>
            {
                logger.LogWebRtcSctpConnecting(state);

                if (state == RTCSctpTransportState.Connected)
                {
                    onSctpConnectedTcs.TrySetResult(true);
                }
            };

            var startTime = DateTime.Now;

            var completedTask = await Task.WhenAny(onSctpConnectedTcs.Task, Task.Delay(SCTP_ASSOCIATE_TIMEOUT_SECONDS * 1000)).ConfigureAwait(false);

            if (sctp.state != RTCSctpTransportState.Connected)
            {
                var duration = DateTime.Now.Subtract(startTime).TotalMilliseconds;

                if (completedTask != onSctpConnectedTcs.Task)
                {
                    throw new SipSorceryException($"SCTP association timed out after {duration:0.##}ms with association in state {sctp.RTCSctpAssociation.State} when attempting to create a data channel.");
                }
                else
                {
                    throw new SipSorceryException($"SCTP association failed after {duration:0.##}ms with association in state {sctp.RTCSctpAssociation.State} when attempting to create a data channel.");
                }
            }
        }
    }

    /// <summary>
    /// Adds a new data channel to the peer connection.
    /// </summary>
    /// <remarks>
    /// WebRTC API definition:
    /// https://www.w3.org/TR/webrtc/#methods-11
    /// </remarks>
    /// <param name="label">The label used to identify the data channel.</param>
    /// <returns>The data channel created.</returns>
    public async Task<RTCDataChannel> createDataChannel(string label, RTCDataChannelInit? init = null)
    {
        logger.LogWebRtcDataChannelCreate(label);

        var channel = new RTCDataChannel(sctp, init)
        {
            label = label,
        };

        if (connectionState == RTCPeerConnectionState.connected)
        {
            // If the peer connection is not in a connected state there's no point doing anything
            // with the SCTP transport. If the peer connection does connect then a check will
            // be made for any pending data channels and the SCTP operations will be done then.

            if (sctp is null || sctp.state != RTCSctpTransportState.Connected)
            {
                throw new SipSorceryException("No SCTP transport is available.");
            }
            else
            {
                if (sctp.RTCSctpAssociation is null ||
                    sctp.RTCSctpAssociation.State != SctpAssociationState.Established)
                {
                    await InitialiseSctpAssociation().ConfigureAwait(false);
                }

                _dataChannels.AddActiveChannel(channel);
                OpenDataChannel(channel);

                // Wait for the DCEP ACK from the remote peer.
                var isopen = new TaskCompletionSource<string>(TaskCreationOptions.RunContinuationsAsynchronously);
                channel.onopen += () => isopen.TrySetResult(string.Empty);
                channel.onerror += (err) => isopen.TrySetResult(err);
                var error = await isopen.Task.ConfigureAwait(false);

                if (!string.IsNullOrEmpty(error))
                {
                    throw new SipSorceryException($"Data channel creation failed with: {error}");
                }
                else
                {
                    return channel;
                }
            }
        }
        else
        {
            // Data channels can be created prior to the SCTP transport being available.
            // They will act as placeholders and then be opened once the SCTP transport 
            // becomes available.
            _dataChannels.AddPendingChannel(channel);
            return channel;
        }
    }

    /// <summary>
    /// Sends the Data Channel Establishment Protocol (DCEP) OPEN message to configure the data
    /// channel on the remote peer.
    /// </summary>
    /// <param name="dataChannel">The data channel to open.</param>
    private void OpenDataChannel(RTCDataChannel dataChannel)
    {
        if (dataChannel.negotiated)
        {
            logger.LogWebRtcDataChannelNegotiated(dataChannel.label, dataChannel.id);
            dataChannel.GotAck();
        }
        else if (dataChannel.id.HasValue)
        {
            logger.LogWebRtcDataChannelOpenAttempt(dataChannel.label, dataChannel.id);
            dataChannel.SendDcepOpen();
        }
        else
        {
            logger.LogWebRtcDataChannelIdOpenAttemptFailed();
        }
    }

    /// <summary>
    ///  DtlsHandshake requires DtlsSrtpTransport to work.
    ///  DtlsSrtpTransport is similar to C++ DTLS class combined with Srtp class and can perform 
    ///  Handshake as Server or Client in same call. The constructor of transport require a DtlsStrpClient 
    ///  or DtlsSrtpServer to work.
    /// </summary>
    /// <param name="dtlsHandle">The DTLS transport handle to perform the handshake with.</param>
    /// <returns>True if the DTLS handshake is successful or false if not.</returns>
    private bool DoDtlsHandshake(DtlsSrtpTransport dtlsHandle)
    {
        logger.LogWebRtcDtlsHandshakeStarting();

        var rtpChannel = PrimaryStream.GetRTPChannel();

        dtlsHandle.OnDataReady += (buf)
            =>
            {
                Debug.Assert(rtpChannel is { });
                Debug.Assert(PrimaryStream.DestinationEndPoint is { });
                rtpChannel.Send(RTPChannelSocketsEnum.RTP, PrimaryStream.DestinationEndPoint, buf);
            };

        var handshakeResult = dtlsHandle.DoHandshake(out var handshakeError);

        if (!handshakeResult)
        {
            handshakeError = handshakeError ?? "unknown";
            logger.LogWebRtcDtlsHandshakeWarn(handshakeError);
            Close("dtls handshake failed");
            return false;
        }
        else
        {
            logger.LogWebRtcDtlsHandshakeResult(handshakeResult, dtlsHandle.IsHandshakeComplete());

            var expectedFp = RemotePeerDtlsFingerprint;
            Debug.Assert(expectedFp is { });
            Debug.Assert(expectedFp.algorithm is { });
            Debug.Assert(dtlsHandle is { });
            var remoteCertificate = dtlsHandle.GetRemoteCertificate();
            Debug.Assert(remoteCertificate is { });
            var tlsCertificate = remoteCertificate.GetCertificateAt(0);
            Debug.Assert(tlsCertificate is { });
            var remoteFingerprint = DtlsUtils.Fingerprint(expectedFp.algorithm, tlsCertificate);

            if (!string.Equals(remoteFingerprint.value, expectedFp.value, StringComparison.OrdinalIgnoreCase))
            {
                logger.LogWebRtcDtlsFingerprintMismatch(expectedFp, remoteFingerprint);
                Close("dtls fingerprint mismatch");
                return false;
            }
            else
            {
                logger.LogWebRtcRemoteCertificateFingerprint(remoteFingerprint.value, remoteFingerprint.algorithm);

                SetGlobalSecurityContext(dtlsHandle.ProtectRTP,
                    dtlsHandle.UnprotectRTP,
                    dtlsHandle.ProtectRTCP,
                    dtlsHandle.UnprotectRTCP);

                IsDtlsNegotiationComplete = true;

                return true;
            }
        }
    }

    /// <summary>
    /// Event handler for TLS alerts from the DTLS transport.
    /// </summary>
    /// <param name="alertLevel">The level of the alert: warning or critical.</param>
    /// <param name="alertType">The type of the alert.</param>
    /// <param name="alertDescription">An optional description for the alert.</param>
    private void OnDtlsAlert(TlsAlertLevelsEnum alertLevel, TlsAlertTypesEnum alertType, string alertDescription)
    {
        if (alertType == TlsAlertTypesEnum.CloseNotify)
        {
            logger.LogWebRtcSctpTransportClose();

            // No point keeping the SCTP association open if there is no DTLS transport available.
            sctp?.Close();
        }
        else
        {
            var alertMsg = !string.IsNullOrEmpty(alertDescription) ? $": {alertDescription}" : ".";
            logger.LogWebRtcDtlsAlert(alertLevel, alertType, alertMsg);
        }
    }

    /// <summary>
    /// Close the session if the instance is out of scope.
    /// </summary>
    protected override void Dispose(bool disposing)
    {
        Close("disposed");
    }

    /// <summary>
    /// Close the session if the instance is out of scope.
    /// </summary>
    public override void Dispose()
    {
        Close("disposed");
    }
}
